{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///localforage.min.js","webpack:///webpack/bootstrap db73142676192a40bbf6","webpack:///./src/localforage.js","webpack:///./src/utils/promise.js","webpack:///./src/utils/executeCallback.js","webpack:///./src/utils/serializer.js","webpack:///./src/utils/createBlob.js","webpack:///./src/utils/idb.js","webpack:///./~/process/browser.js","webpack:///./src/drivers/indexeddb.js","webpack:///./src/drivers/localstorage.js","webpack:///./src/drivers/websql.js","webpack:///./src/utils/executeTwoCallbacks.js","webpack:///./src/utils/isIndexedDBValid.js","webpack:///./src/utils/isLocalStorageValid.js","webpack:///./src/utils/isWebSQLValid.js","webpack:///./~/immediate/lib/index.js","webpack:///./~/lie/lib/index.js","webpack:///./~/lie/polyfill.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","callWhenReady","localForageInstance","libraryMethod","_args","arguments","ready","then","apply","extend","i","length","arg","key","hasOwnProperty","isArray","slice","isLibraryDriver","driverName","driver","DriverType","_typeof","Symbol","iterator","constructor","_isIndexedDBValid","_isIndexedDBValid2","_isWebSQLValid","_isWebSQLValid2","_isLocalStorageValid","_isLocalStorageValid2","_indexeddb","_indexeddb2","_websql","_websql2","_localstorage","_localstorage2","_serializer","_serializer2","_promise","_promise2","_executeTwoCallbacks","_executeTwoCallbacks2","CustomDrivers","INDEXEDDB","LOCALSTORAGE","WEBSQL","DefaultDriverOrder","LibraryMethods","DefaultConfig","description","name","size","storeName","version","driverSupport","Array","Object","prototype","toString","LocalForage","options","_defaultConfig","_config","_driverSet","_initDriver","_ready","_dbInfo","_wrapLibraryMethodsWithReady","setDriver","config","Error","replace","defineDriver","driverObject","callback","errorCallback","promise","resolve","reject","_driver","complianceError","namingError","customDriverMethods","concat","customDriverMethod","supportPromise","_support","supportResult","e","getDriver","self","getDriverPromise","getSerializer","serializerPromise","drivers","setDriverToConfig","initDriver","supportedDrivers","driverPromiseLoop","currentDriverIndex","_extend","_initStorage","error","_getSupportedDrivers","oldDriverSetDone","supports","libraryMethodsAndProperties","len","push","createInstance","Promise","executeCallback","result","stringToBuffer","serializedString","encoded1","encoded2","encoded3","encoded4","bufferLength","buffer","ArrayBuffer","bytes","Uint8Array","BASE_CHARS","indexOf","bufferToString","base64String","substring","serialize","value","valueString","marker","SERIALIZED_MARKER","TYPE_ARRAYBUFFER","TYPE_INT8ARRAY","TYPE_UINT8ARRAY","TYPE_UINT8CLAMPEDARRAY","TYPE_INT16ARRAY","TYPE_UINT16ARRAY","TYPE_INT32ARRAY","TYPE_UINT32ARRAY","TYPE_FLOAT32ARRAY","TYPE_FLOAT64ARRAY","fileReader","FileReader","onload","str","BLOB_TYPE_PREFIX","type","TYPE_BLOB","readAsArrayBuffer","JSON","stringify","console","deserialize","SERIALIZED_MARKER_LENGTH","parse","blobType","TYPE_SERIALIZED_MARKER_LENGTH","BLOB_TYPE_PREFIX_REGEX","test","matcher","match","_createBlob2","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","_createBlob","localforageSerializer","createBlob","parts","properties","Blob","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","append","getBlob","getIDB","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","idb","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","setTimeout","run","clearTimeout","Item","fun","array","noop","process","nextTick","args","title","browser","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","_binStringToArrayBuffer","bin","buf","arr","charCodeAt","_blobAjax","url","xhr","XMLHttpRequest","open","withCredentials","responseType","onreadystatechange","readyState","status","response","getResponseHeader","send","_checkBlobSupportWithoutCaching","blob","txn","transaction","DETECT_BLOB_SUPPORT_STORE","objectStore","put","oncomplete","blobTxn","getBlobReq","get","onerror","onsuccess","storedBlob","target","URL","createObjectURL","res","revokeObjectURL","onabort","_checkBlobSupport","supportsBlobs","_deferReadiness","dbInfo","dbContext","dbContexts","deferredOperation","deferredOperations","dbReady","_advanceReadiness","pop","_getConnection","upgradeNeeded","db","close","dbArgs","openreq","_idb2","onupgradeneeded","createObjectStore","oldVersion","ex","warn","newVersion","_getOriginalConnection","_getUpgradedConnection","_isUpgradeNeeded","defaultVersion","isNewStore","objectStoreNames","contains","isDowngrade","isUpgrade","incVersion","_encodeBlob","reader","onloadend","base64","btoa","__local_forage_encoded_blob","data","readAsBinaryString","_decodeBlob","encodedBlob","arrayBuff","atob","_isEncodedBlob","_fullyReady","_initReady","ignoreErrors","forages","initPromises","j","forage","all","k","getItem","String","store","req","undefined","_executeCallback2","iterate","openCursor","iterationNumber","cursor","setItem","blobSupport","err","removeItem","clear","count","n","advanced","advance","keys","_idb","_executeCallback","asyncStorage","keyPrefix","serializer","localStorage","keyPrefixLength","originalValue","localStorageWrapper","dbInfoPromise","openDatabase","t","executeSql","results","rows","item","sqlError","code","QUOTA_ERR","webSQLStorage","executeTwoCallbacks","isIndexedDBValid","navigator","userAgent","IDBKeyRange","isLocalStorageValid","isWebSQLValid","global","oldQueue","immediate","task","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","called","observer","element","document","createTextNode","observe","characterData","setImmediate","MessageChannel","createElement","scriptEl","parentNode","removeChild","documentElement","appendChild","channel","port1","onmessage","port2","postMessage","INTERNAL","resolver","state","PENDING","outcome","handled","UNHANDLED","safelyResolveThenable","QueueItem","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","func","returnValue","handlers","getThen","thenable","onError","onSuccess","tryToUnwrap","tryCatch","out","reason","iterable","allResolver","resolveFromAll","outValue","values","resolved","race","REJECTED","FULFILLED"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,YAAAD,IAEAD,EAAA,YAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,EAASM,GAE/B,YA0CA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCEpCjH,QAASC,GAAcC,EAAqBC,GACxCD,EAAoBC,GAAiB,WACjC,GAAIC,GAAQC,SACZ,OAAOH,GAAoBI,QAAQC,KAAK,WACpC,MAAOL,GAAoBC,GAAeK,MAAMN,EAAqBE,MAKjF,QAASK,KACL,IAAK,GAAIC,GAAI,EAAGA,EAAIL,UAAUM,OAAQD,IAAK,CACvC,GAAIE,GAAMP,UAAUK,EAEpB,IAAIE,EACA,IAAK,GAAIC,KAAOD,GACRA,EAAIE,eAAeD,KACfE,EAAQH,EAAIC,IACZR,UAAU,GAAGQ,GAAOD,EAAIC,GAAKG,QAE7BX,UAAU,GAAGQ,GAAOD,EAAIC,IAO5C,MAAOR,WAAU,GAGrB,QAASY,GAAgBC,GACrB,IAAK,GAAIC,KAAUC,GACf,GAAIA,EAAWN,eAAeK,IAC1BC,EAAWD,KAAYD,EACvB,OAAO,CAIf,QAAO,EF3CVxC,EAAQiB,YAAa,CAErB,IAAI0B,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAU7B,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAX4B,SAAyB5B,EAAI8B,cAAgBF,OAAS,eAAkB5B,IE5D3O+B,EAAAzC,EAAA,IFgEK0C,EAAqBjC,EAAuBgC,GE/DjDE,EAAA3C,EAAA,IFmEK4C,EAAkBnC,EAAuBkC,GElE9CE,EAAA7C,EAAA,IFsEK8C,EAAwBrC,EAAuBoC,GErEpDE,EAAA/C,EAAA,GFyEKgD,EAAcvC,EAAuBsC,GExE1CE,EAAAjD,EAAA,GF4EKkD,EAAWzC,EAAuBwC,GE3EvCE,EAAAnD,EAAA,GF+EKoD,EAAiB3C,EAAuB0C,GE9E7CE,EAAArD,EAAA,GFkFKsD,EAAe7C,EAAuB4C,GEjF3CE,EAAAvD,EAAA,GFqFKwD,EAAY/C,EAAuB8C,GEpFxCE,EAAAzD,EAAA,IFwFK0D,EAAwBjD,EAAuBgD,GEpFhDE,KAEAvB,GACAwB,UAAW,eACXC,aAAc,sBACdC,OAAQ,iBAGRC,GACA3B,EAAWwB,UACXxB,EAAW0B,OACX1B,EAAWyB,cAGXG,GACA,QACA,UACA,UACA,MACA,OACA,SACA,aACA,WAGAC,GACAC,YAAa,GACb/B,OAAQ4B,EAAmB/B,QAC3BmC,KAAM,cAGNC,KAAM,QACNC,UAAW,gBACXC,QAAS,GAGTC,IAMJA,GAAcnC,EAAWwB,YAAa,EAAAlB,gBAEtC6B,EAAcnC,EAAW0B,SAAU,EAAAlB,gBAEnC2B,EAAcnC,EAAWyB,eAAgB,EAAAf,eAEzC,IAAIf,GAAUyC,MAAMzC,SAAW,SAASH,GAChC,MAA+C,mBAAxC6C,OAAOC,UAAUC,SAAStE,KAAKuB,IA2CxCgD,EF8Ea,WE7Ef,QAAAA,GAAYC,GAAShE,EAAAf,KAAA8E,GACjB9E,KAAK8D,UAAYxB,EAAWwB,UAC5B9D,KAAK+D,aAAezB,EAAWyB,aAC/B/D,KAAKgE,OAAS1B,EAAW0B,OAEzBhE,KAAKgF,eAAiBrD,KAAWwC,GACjCnE,KAAKiF,QAAUtD,KAAW3B,KAAKgF,eAAgBD,GAC/C/E,KAAKkF,WAAa,KAClBlF,KAAKmF,YAAc,KACnBnF,KAAKoF,QAAS,EACdpF,KAAKqF,QAAU,KAEfrF,KAAKsF,+BACLtF,KAAKuF,UAAUvF,KAAKiF,QAAQ5C,QFyU/B,MAhPAyC,GAAYF,UElFbY,OFkFgC,SElFzBT,GAIH,GAAwB,YAApB,mBAAOA,GAAP,YAAAxC,EAAOwC,IAAuB,CAG9B,GAAI/E,KAAKoF,OACL,MAAO,IAAIK,OAAM,uDAIrB,KAAK,GAAI7D,KAAKmD,GACA,cAANnD,IACAmD,EAAQnD,GAAKmD,EAAQnD,GAAG8D,QAAQ,MAAO,MAG3C1F,KAAKiF,QAAQrD,GAAKmD,EAAQnD,EAS9B,OAJI,UAAYmD,IAAWA,EAAQ1C,QAC/BrC,KAAKuF,UAAUvF,KAAKiF,QAAQ5C,SAGzB,EACJ,MAAwB,gBAAb0C,GACP/E,KAAKiF,QAAQF,GAEb/E,KAAKiF,SFyFnBH,EAAYF,UEnFbe,aFmFsC,SEnFzBC,EAAcC,EAAUC,GACjC,GAAIC,GAAU,GAAArC,cAAY,SAASsC,EAASC,GACxC,IACI,GAAI7D,GAAawD,EAAaM,QAC1BC,EAAkB,GAAIV,OACtB,wFAGAW,EAAc,GAAIX,OAClB,sCAAwCG,EAAaM,QAKzD,KAAKN,EAAaM,QAEd,WADAD,GAAOE,EAGX,IAAIhE,EAAgByD,EAAaM,SAE7B,WADAD,GAAOG,EAKX,KAAK,GADDC,GAAsBnC,EAAeoC,OAAO,gBACvC1E,EAAI,EAAGA,EAAIyE,EAAoBxE,OAAQD,IAAK,CACjD,GAAI2E,GAAqBF,EAAoBzE,EAC7C,KAAK2E,IAAuBX,EAAaW,IACO,kBAArCX,GAAaW,GAEpB,WADAN,GAAOE,GAKf,GAAIK,GAAiB9C,aAAQsC,SAAQ,EACjC,aAAcJ,KAEVY,EADAZ,EAAaa,UAA6C,kBAA1Bb,GAAaa,SAC5Bb,EAAaa,WAEb/C,aAAQsC,UAAUJ,EAAaa,WAIxDD,EAAe/E,KAAK,SAASiF,GACzBjC,EAAcrC,GAAcsE,EAC5B7C,EAAczB,GAAcwD,EAC5BI,KACDC,GACL,MAAOU,GACLV,EAAOU,KAKf,QADA,EAAA/C,cAAoBmC,EAASF,EAAUC,GAChCC,GFgFVjB,EAAYF,UE7EbvC,OF6EgC,WE5E5B,MAAOrC,MAAKkG,SAAW,MFgF1BpB,EAAYF,UE7EbgC,UF6EmC,SE7EzBxE,EAAYyD,EAAUC,GAC5B,GAAIe,GAAO7G,KACP8G,EAAmBpD,aAAQsC,UAAUvE,KAAK,WAC1C,IAAIU,EAAgBC,GASb,IAAIyB,EAAczB,GACrB,MAAOyB,GAAczB,EAErB,MAAM,IAAIqD,OAAM,qBAXhB,OAAQrD,GACJ,IAAKyE,GAAK/C,UACN,MAAAZ,aACJ,KAAK2D,GAAK9C,aACN,MAAAT,aACJ,KAAKuD,GAAK7C,OACN,MAAAZ,gBAShB,QADA,EAAAQ,cAAoBkD,EAAkBjB,EAAUC,GACzCgB,GFgFVhC,EAAYF,UE7EbmC,cF6EuC,SE7EzBlB,GACV,GAAImB,GAAoBtD,aAAQsC,QAARxC,aAExB,QADA,EAAAI,cAAoBoD,EAAmBnB,GAChCmB,GFgFVlC,EAAYF,UE7EbpD,MF6E+B,SE7EzBqE,GACF,GAAIgB,GAAO7G,KAEP+F,EAAUc,EAAK3B,WAAWzD,KAAK,WAK/B,MAJoB,QAAhBoF,EAAKzB,SACLyB,EAAKzB,OAASyB,EAAK1B,eAGhB0B,EAAKzB,QAIhB,QADA,EAAAxB,cAAoBmC,EAASF,EAAUA,GAChCE,GFgFVjB,EAAYF,UE7EbW,UF6EmC,SE7EzB0B,EAASpB,EAAUC,GASzB,QAASoB,KACLL,EAAK5B,QAAQ5C,OAASwE,EAAKxE,SAG/B,QAAS8E,GAAWC,GAChB,MAAO,YAGH,QAASC,KACL,KAAOC,EAAqBF,EAAiBvF,QAAQ,CACjD,GAAIO,GAAagF,EAAiBE,EAMlC,OALAA,KAEAT,EAAKxB,QAAU,KACfwB,EAAKzB,OAAS,KAEPyB,EAAKD,UAAUxE,GACjBX,KAAK,SAAAY,GAKF,MAJAwE,GAAKU,QAAQlF,GACb6E,IAEAL,EAAKzB,OAASyB,EAAKW,aAAaX,EAAK5B,SAC9B4B,EAAKzB,SANbyB,SAQIQ,GAGfH,GACA,IAAIO,GAAQ,GAAIhC,OAAM,qCAEtB,OADAoB,GAAK3B,WAAaxB,aAAQuC,OAAOwB,GAC1BZ,EAAK3B,WAxBhB,GAAIoC,GAAqB,CA2BzB,OAAOD,MAzCf,GAAIR,GAAO7G,IAENiC,GAAQgF,KACTA,GAAWA,GAGf,IAAIG,GAAmBpH,KAAK0H,qBAAqBT,GA0C7CU,EAAuC,OAApB3H,KAAKkF,WACxBlF,KAAKkF,WAALlF,SAAsB,iBAAM0D,cAAQsC,YACpCtC,aAAQsC,SAsBZ,OApBAhG,MAAKkF,WAAayC,EAAiBlG,KAAK,WACpC,GAAIW,GAAagF,EAAiB,EAIlC,OAHAP,GAAKxB,QAAU,KACfwB,EAAKzB,OAAS,KAEPyB,EAAKD,UAAUxE,GACjBX,KAAK,SAAAY,GACFwE,EAAKX,QAAU7D,EAAO6D,QACtBgB,IACAL,EAAKvB,+BACLuB,EAAK1B,YAAcgC,EAAWC,OAVxBO,SAYT,WACLT,GACA,IAAIO,GAAQ,GAAIhC,OAAM,qCAEtB,OADAoB,GAAK3B,WAAaxB,aAAQuC,OAAOwB,GAC1BZ,EAAK3B,cAGhB,EAAAtB,cAAoB5D,KAAKkF,WAAYW,EAAUC,GACxC9F,KAAKkF,YF6EfJ,EAAYF,UE1EbgD,SF0EkC,SE1EzBxF,GACL,QAASqC,EAAcrC,IF6E1B0C,EAAYF,UE1Eb2C,QF0EiC,SE1EzBM,GACJlG,EAAO3B,KAAM6H,IF6EhB/C,EAAYF,UE1Eb8C,qBF0E8C,SE1EzBT,GAEjB,IAAK,GADDG,MACKxF,EAAI,EAAGkG,EAAMb,EAAQpF,OAAYiG,EAAJlG,EAASA,IAAK,CAChD,GAAIQ,GAAa6E,EAAQrF,EACrB5B,MAAK4H,SAASxF,IACdgF,EAAiBW,KAAK3F,GAG9B,MAAOgF,IF6EVtC,EAAYF,UE1EbU,6BF0EsD,WErElD,IAAK,GAAI1D,GAAI,EAAGA,EAAIsC,EAAerC,OAAQD,IACvCT,EAAcnB,KAAMkE,EAAetC,KF8E1CkD,EAAYF,UE1EboD,eF0EwC,SE1EzBjD,GACX,MAAO,IAAID,GAAYC,IF6EnBD,IAOXlF,cE9Ec,GAAIkF,GF+ElBjF,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,EAASM,GAE/B,YAEAN,GAAQiB,YAAa,EG7ctBX,EAAQ,IHidPN,aGhdcqI,QHiddpI,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,GAEtB,YI1dD,SAASsI,GAAgBnC,EAASF,GAC1BA,GACAE,EAAQtE,KAAK,SAAS0G,GAClBtC,EAAS,KAAMsC,IAChB,SAASV,GACR5B,EAAS4B,KJudpB7H,EAAQiB,YAAa,EAWrBjB,aI7dcsI,EJ8ddrI,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,EAASM,GAE/B,YAQA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GK1dxF,QAASwH,GAAeC,GAEpB,GAEIzG,GAEA0G,EAAUC,EAAUC,EAAUC,EAJ9BC,EAAyC,IAA1BL,EAAiBxG,OAChCiG,EAAMO,EAAiBxG,OAEvBnB,EAAI,CAG8C,OAAlD2H,EAAiBA,EAAiBxG,OAAS,KAC3C6G,IACsD,MAAlDL,EAAiBA,EAAiBxG,OAAS,IAC3C6G,IAIR,IAAIC,GAAS,GAAIC,aAAYF,GACzBG,EAAQ,GAAIC,YAAWH,EAE3B,KAAK/G,EAAI,EAAOkG,EAAJlG,EAASA,GAAK,EACtB0G,EAAWS,EAAWC,QAAQX,EAAiBzG,IAC/C2G,EAAWQ,EAAWC,QAAQX,EAAiBzG,EAAI,IACnD4G,EAAWO,EAAWC,QAAQX,EAAiBzG,EAAI,IACnD6G,EAAWM,EAAWC,QAAQX,EAAiBzG,EAAI,IAGnDiH,EAAMnI,KAAQ4H,GAAY,EAAMC,GAAY,EAC5CM,EAAMnI,MAAoB,GAAX6H,IAAkB,EAAMC,GAAY,EACnDK,EAAMnI,MAAoB,EAAX8H,IAAiB,EAAiB,GAAXC,CAE1C,OAAOE,GAKX,QAASM,GAAeN,GAEpB,GAEI/G,GAFAiH,EAAQ,GAAIC,YAAWH,GACvBO,EAAe,EAGnB,KAAKtH,EAAI,EAAGA,EAAIiH,EAAMhH,OAAQD,GAAK,EAE/BsH,GAAgBH,EAAWF,EAAMjH,IAAM,GACvCsH,GAAgBH,GAAwB,EAAXF,EAAMjH,KAAW,EAAMiH,EAAMjH,EAAI,IAAM,GACpEsH,GAAgBH,GAA4B,GAAfF,EAAMjH,EAAI,KAAY,EAAMiH,EAAMjH,EAAI,IAAM,GACzEsH,GAAgBH,EAA0B,GAAfF,EAAMjH,EAAI,GASzC,OANKiH,GAAMhH,OAAS,IAAO,EACvBqH,EAAeA,EAAaC,UAAU,EAAGD,EAAarH,OAAS,GAAK,IAC7DgH,EAAMhH,OAAS,IAAM,IAC5BqH,EAAeA,EAAaC,UAAU,EAAGD,EAAarH,OAAS,GAAK,MAGjEqH,EAMX,QAASE,GAAUC,EAAOxD,GACtB,GAAIyD,GAAc,EASlB,IARID,IACAC,EAAcD,EAAMxE,YAOpBwE,IAA+B,yBAArBA,EAAMxE,YAChBwE,EAAMV,QACsB,yBAA5BU,EAAMV,OAAO9D,YAAwC,CAGrD,GAAI8D,GACAY,EAASC,CAETH,aAAiBT,cACjBD,EAASU,EACTE,GAAUE,IAEVd,EAASU,EAAMV,OAEK,uBAAhBW,EACAC,GAAUG,EACa,wBAAhBJ,EACPC,GAAUI,EACa,+BAAhBL,EACPC,GAAUK,EACa,wBAAhBN,EACPC,GAAUM,EACa,yBAAhBP,EACPC,GAAUO,EACa,wBAAhBR,EACPC,GAAUQ,EACa,yBAAhBT,EACPC,GAAUS,EACa,0BAAhBV,EACPC,GAAUU,EACa,0BAAhBX,EACPC,GAAUW,EAEVrE,EAAS,GAAIJ,OAAM,wCAI3BI,EAAS0D,EAASN,EAAeN,QAC9B,IAAoB,kBAAhBW,EAAiC,CAExC,GAAIa,GAAa,GAAIC,WAErBD,GAAWE,OAAS,WAEhB,GAAIC,GAAMC,EAAmBlB,EAAMmB,KAAO,IACtCvB,EAAejJ,KAAKmI,OAExBtC,GAAS2D,EAAoBiB,EAAYH,IAG7CH,EAAWO,kBAAkBrB,OAE7B,KACIxD,EAAS8E,KAAKC,UAAUvB,IAC1B,MAAO1C,GACLkE,QAAQpD,MAAM,8CACV4B,GAEJxD,EAAS,KAAMc,IAa3B,QAASmE,GAAYzB,GAIjB,GAAIA,EAAMF,UAAU,EACZ4B,KAA8BvB,EAClC,MAAOmB,MAAKK,MAAM3B,EAMtB,IAII4B,GAJA5C,EAAmBgB,EAAMF,UAAU+B,GACnCV,EAAOnB,EAAMF,UAAU4B,EACvBG,EAKJ,IAAIV,IAASC,GAAaU,EAAuBC,KAAK/C,GAAmB,CACrE,GAAIgD,GAAUhD,EAAiBiD,MAAMH,EACrCF,GAAWI,EAAQ,GACnBhD,EAAmBA,EAAiBc,UAAUkC,EAAQ,GAAGxJ,QAE7D,GAAI8G,GAASP,EAAeC,EAI5B,QAAQmC,GACJ,IAAKf,GACD,MAAOd,EACX,KAAK8B,GACD,OAAO,EAAAc,eAAY5C,IAAU6B,KAAMS,GACvC,KAAKvB,GACD,MAAO,IAAI8B,WAAU7C,EACzB,KAAKgB,GACD,MAAO,IAAIb,YAAWH,EAC1B,KAAKiB,GACD,MAAO,IAAI6B,mBAAkB9C,EACjC,KAAKkB,GACD,MAAO,IAAI6B,YAAW/C,EAC1B,KAAKmB,GACD,MAAO,IAAI6B,aAAYhD,EAC3B,KAAKoB,GACD,MAAO,IAAI6B,YAAWjD,EAC1B,KAAKqB,GACD,MAAO,IAAI6B,aAAYlD,EAC3B,KAAKsB,GACD,MAAO,IAAI6B,cAAanD,EAC5B,KAAKuB,GACD,MAAO,IAAI6B,cAAapD,EAC5B,SACI,KAAM,IAAIlD,OAAM,iBAAmB+E,ILmR9C5K,EAAQiB,YAAa,CKhftB,IAAAmL,GAAA9L,EAAA,GLofKqL,EAAe5K,EAAuBqL,GK/evCjD,EAAa,mEAEbwB,EAAmB,uBACnBY,EAAyB,gCAEzB3B,EAAoB,YACpBuB,EAA2BvB,EAAkB3H,OAG7C4H,EAAmB,OACnBgB,EAAY,OACZf,EAAiB,OACjBC,EAAkB,OAClBC,EAAyB,OACzBC,EAAkB,OAClBE,EAAkB,OAClBD,EAAmB,OACnBE,EAAmB,OACnBC,EAAoB,OACpBC,EAAoB,OACpBgB,EAAgCH,EAChCtB,EAAiB5H,OAuMjBoK,GACA7C,UAAWA,EACX0B,YAAaA,EACb1C,eAAgBA,EAChBa,eAAgBA,ELkfnBrJ,cK/ecqM,ELgfdpM,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,GAEtB,YMxtBD,SAASsM,GAAWC,EAAOC,GAEvBD,EAAQA,MACRC,EAAaA,KACb,KACI,MAAO,IAAIC,MAAKF,EAAOC,GACzB,MAAOzF,GACL,GAAe,cAAXA,EAAEtC,KACF,KAAMsC,EAOV,KAAK,GALD2F,GAAiC,mBAAhBC,aAA8BA,YACtB,mBAAlBC,eAAgCA,cACb,mBAAnBC,gBAAiCA,eACxCC,kBACAC,EAAU,GAAIL,GACT1K,EAAI,EAAGA,EAAIuK,EAAMtK,OAAQD,GAAK,EACnC+K,EAAQC,OAAOT,EAAMvK,GAEzB,OAAO+K,GAAQE,QAAQT,EAAW5B,ONwsBzC5K,EAAQiB,YAAa,EA0BrBjB,aM9tBcsM,EN+tBdrM,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,GAEtB,YOjwBD,SAASkN,KAEL,MAAyB,mBAAdC,WACAA,UAEoB,mBAApBC,iBACAA,gBAEiB,mBAAjBC,cACAA,aAEe,mBAAfC,YACAA,WAEgB,mBAAhBC,aACAA,YADX,OPqvBHvN,EAAQiB,YAAa,COhvBtB,IAAIuM,GAAMN,GPqwBTlN,cOpwBcwN,EPqwBdvN,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,GQrxBvB,QAAAyN,KACAC,GAAA,EACAC,EAAA1L,OACA2L,EAAAD,EAAAjH,OAAAkH,GAEAC,EAAA,GAEAD,EAAA3L,QACA6L,IAIA,QAAAA,KACA,IAAAJ,EAAA,CAGA,GAAAK,GAAAC,WAAAP,EACAC,IAAA,CAGA,KADA,GAAAxF,GAAA0F,EAAA3L,OACAiG,GAAA,CAGA,IAFAyF,EAAAC,EACAA,OACAC,EAAA3F,GACAyF,GACAA,EAAAE,GAAAI,KAGAJ,GAAA,GACA3F,EAAA0F,EAAA3L,OAEA0L,EAAA,KACAD,GAAA,EACAQ,aAAAH,IAiBA,QAAAI,GAAAC,EAAAC,GACAjO,KAAAgO,MACAhO,KAAAiO,QAYA,QAAAC,MAtEA,GAGAX,GAHAY,EAAAtO,EAAAD,WACA4N,KACAF,GAAA,EAEAG,EAAA,EAsCAU,GAAAC,SAAA,SAAAJ,GACA,GAAAK,GAAA,GAAA3J,OAAAnD,UAAAM,OAAA,EACA,IAAAN,UAAAM,OAAA,EACA,OAAAD,GAAA,EAAuBA,EAAAL,UAAAM,OAAsBD,IAC7CyM,EAAAzM,EAAA,GAAAL,UAAAK,EAGA4L,GAAAzF,KAAA,GAAAgG,GAAAC,EAAAK,IACA,IAAAb,EAAA3L,QAAAyL,GACAM,WAAAF,EAAA,IASAK,EAAAnJ,UAAAiJ,IAAA,WACA7N,KAAAgO,IAAAtM,MAAA,KAAA1B,KAAAiO,QAEAE,EAAAG,MAAA,UACAH,EAAAI,SAAA,EACAJ,EAAAK,OACAL,EAAAM,QACAN,EAAA3J,QAAA,GACA2J,EAAAO,YAIAP,EAAAQ,GAAAT,EACAC,EAAAS,YAAAV,EACAC,EAAAU,KAAAX,EACAC,EAAAW,IAAAZ,EACAC,EAAAY,eAAAb,EACAC,EAAAa,mBAAAd,EACAC,EAAAc,KAAAf,EAEAC,EAAAe,QAAA,SAAA7K,GACA,SAAAoB,OAAA,qCAGA0I,EAAAgB,IAAA,WAA2B,WAC3BhB,EAAAiB,MAAA,SAAAC,GACA,SAAA5J,OAAA,mCAEA0I,EAAAmB,MAAA,WAA4B,WRoyBtB,SAASzP,EAAQD,EAASM,GAE/B,YAoBA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GSn4BxF,QAAS2O,GAAwBC,GAI7B,IAAK,GAHD3N,GAAS2N,EAAI3N,OACb4N,EAAM,GAAI7G,aAAY/G,GACtB6N,EAAM,GAAI5G,YAAW2G,GAChB7N,EAAI,EAAOC,EAAJD,EAAYA,IACxB8N,EAAI9N,GAAK4N,EAAIG,WAAW/N,EAE5B,OAAO6N,GAMX,QAASG,GAAUC,GACf,MAAO,IAAAnM,cAAY,SAASsC,EAASC,GACjC,GAAI6J,GAAM,GAAIC,eACdD,GAAIE,KAAK,MAAOH,GAChBC,EAAIG,iBAAkB,EACtBH,EAAII,aAAe,cAEnBJ,EAAIK,mBAAqB,WACrB,MAAuB,KAAnBL,EAAIM,WAGW,MAAfN,EAAIO,OACGrK,GACHsK,SAAUR,EAAIQ,SACd9F,KAAMsF,EAAIS,kBAAkB,sBAGpCtK,IAAQoK,OAAQP,EAAIO,OAAQC,SAAUR,EAAIQ,WAT1C,QAWJR,EAAIU,SAmBZ,QAASC,GAAgCrD,GACrC,MAAO,IAAA1J,cAAY,SAASsC,EAASC,GACjC,GAAIyK,IAAO,EAAAnF,eAAY,KAAMf,KAAM,cAC/BmG,EAAMvD,EAAIwD,aAAaC,GAA4B,YACvDF,GAAIG,YAAYD,GAA2BE,IAAIL,EAAM,OACrDC,EAAIK,WAAa,WAGb,GAAIC,GAAU7D,EAAIwD,aAAaC,GAC3B,aACAK,EAAaD,EAAQH,YACrBD,GAA2BM,IAAI,MACnCD,GAAWE,QAAUnL,EACrBiL,EAAWG,UAAY,SAAS1K,GAE5B,GAAI2K,GAAa3K,EAAE4K,OAAOpJ,OACtB0H,EAAM2B,IAAIC,gBAAgBH,EAE9B1B,GAAUC,GAAKpO,KAAK,SAASiQ,GACzB1L,KAAW0L,GAAoB,cAAbA,EAAIlH,QACvB,WACCxE,GAAQ,KACTvE,KAAK,WACJ+P,IAAIG,gBAAgB9B,OAIhCc,EAAIS,QAAUT,EAAIiB,QAAU3L,IA1BzB,SA2BE,WACL,OAAO,IAIf,QAAS4L,GAAkBzE,GACvB,MAA6B,iBAAlB0E,GACApO,aAAQsC,QAAQ8L,GAEpBrB,EAAgCrD,GAAK3L,KAAK,SAAS4H,GAEtD,MADAyI,GAAgBzI,IAKxB,QAAS0I,GAAgBC,GACrB,GAAIC,GAAYC,EAAWF,EAAO3N,MAG9B8N,IAEJA,GAAkBpM,QAAU,GAAArC,cAAY,SAASsC,GAC7CmM,EAAkBnM,QAAUA,IAIhCiM,EAAUG,mBAAmBrK,KAAKoK,GAG7BF,EAAUI,QAGXJ,EAAUI,QAAUJ,EAAUI,QAAQ5Q,KAAK,WACvC,MAAO0Q,GAAkBpM,UAH7BkM,EAAUI,QAAUF,EAAkBpM,QAQ9C,QAASuM,GAAkBN,GACvB,GAAIC,GAAYC,EAAWF,EAAO3N,MAG9B8N,EAAoBF,EAAUG,mBAAmBG,KAIjDJ,IACAA,EAAkBnM,UAI1B,QAASwM,GAAeR,EAAQS,GAC5B,MAAO,IAAA/O,cAAY,SAASsC,EAASC,GAEjC,GAAI+L,EAAOU,GAAI,CACX,IAAID,EAIA,MAAOzM,GAAQgM,EAAOU,GAHtBX,GAAgBC,GAChBA,EAAOU,GAAGC,QAMlB,GAAIC,IAAUZ,EAAO3N,KAEjBoO,IACAG,EAAO7K,KAAKiK,EAAOxN,QAGvB,IAAIqO,GAAUC,aAAI9C,KAAKtO,MAAToR,aAAoBF,EAE9BH,KACAI,EAAQE,gBAAkB,SAASpM,GAC/B,GAAI+L,GAAKG,EAAQ1K,MACjB,KACIuK,EAAGM,kBAAkBhB,EAAOzN,WACxBoC,EAAEsM,YAAc,GAEhBP,EAAGM,kBAAkBnC,GAE3B,MAAOqC,GACL,GAAgB,oBAAZA,EAAG7O,KAMH,KAAM6O,EALNrI,SAAQsI,KAAK,iBAAmBnB,EAAO3N,KAAO,oCACLsC,EAAEsM,WACvC,eAAiBtM,EAAEyM,WACnB,sBAAwBpB,EAAOzN,UAAY,wBAQ/DsO,EAAQzB,QAAU,WACdnL,EAAO4M,EAAQpL,QAGnBoL,EAAQxB,UAAY,WAChBrL,EAAQ6M,EAAQ1K,QAChBmK,EAAkBN,MAK9B,QAASqB,GAAuBrB,GAC5B,MAAOQ,GAAeR,GAAQ,GAGlC,QAASsB,GAAuBtB,GAC5B,MAAOQ,GAAeR,GAAQ,GAGlC,QAASuB,GAAiBvB,EAAQwB,GAC9B,IAAKxB,EAAOU,GACR,OAAO,CAGX,IAAIe,IAAczB,EAAOU,GAAGgB,iBAAiBC,SAAS3B,EAAOzN,WACzDqP,EAAc5B,EAAOxN,QAAUwN,EAAOU,GAAGlO,QACzCqP,EAAY7B,EAAOxN,QAAUwN,EAAOU,GAAGlO,OAc3C,IAZIoP,IAGI5B,EAAOxN,UAAYgP,GACnB3I,QAAQsI,KAAK,iBAAmBnB,EAAO3N,KAAO,uCACF2N,EAAOU,GAAGlO,QAClD,eAAiBwN,EAAOxN,QAAU,KAG1CwN,EAAOxN,QAAUwN,EAAOU,GAAGlO,SAG3BqP,GAAaJ,EAAY,CAIzB,GAAIA,EAAY,CACZ,GAAIK,GAAa9B,EAAOU,GAAGlO,QAAU,CACjCsP,GAAa9B,EAAOxN,UACpBwN,EAAOxN,QAAUsP,GAIzB,OAAO,EAGX,OAAO,EAIX,QAASC,GAAYrD,GACjB,MAAO,IAAAhN,cAAY,SAASsC,EAASC,GACjC,GAAI+N,GAAS,GAAI5J,WACjB4J,GAAO5C,QAAUnL,EACjB+N,EAAOC,UAAY,SAAStN,GACxB,GAAIuN,GAASC,KAAKxN,EAAE4K,OAAOpJ,QAAU,GACrCnC,IACIoO,6BAA6B,EAC7BC,KAAMH,EACN1J,KAAMkG,EAAKlG,QAGnBwJ,EAAOM,mBAAmB5D,KAKlC,QAAS6D,GAAYC,GACjB,GAAIC,GAAYlF,EAAwBmF,KAAKF,EAAYH,MACzD,QAAO,EAAA9I,eAAYkJ,IAAajK,KAAMgK,EAAYhK,OAItD,QAASmK,GAAetL,GACpB,MAAOA,IAASA,EAAM+K,4BAO1B,QAASQ,GAAY/O,GACjB,GAAIgB,GAAO7G,KAEP+F,EAAUc,EAAKgO,aAAapT,KAAK,WACjC,GAAIwQ,GAAYC,EAAWrL,EAAKxB,QAAQhB,KAExC,OAAI4N,IAAaA,EAAUI,QAChBJ,EAAUI,QADrB,QAMJ,OADAtM,GAAQtE,KAAKoE,EAAUA,GAChBE,EAKX,QAASyB,GAAazC,GAgDlB,QAAS+P,KAGL,MAAOpR,cAAQsC,UAlDnB,GAAIa,GAAO7G,KACPgS,GACAU,GAAI,KAGR,IAAI3N,EACA,IAAK,GAAInD,KAAKmD,GACViN,EAAOpQ,GAAKmD,EAAQnD,EAKvBsQ,KACDA,KAIJ,IAAID,GAAYC,EAAWF,EAAO3N,KAG7B4N,KACDA,GAEI8C,WAEArC,GAAI,KAEJL,QAAS,KAETD,uBAGJF,EAAWF,EAAO3N,MAAQ4N,GAI9BA,EAAU8C,QAAQhN,KAAKlB,GAGlBA,EAAKgO,aACNhO,EAAKgO,WAAahO,EAAKrF,MACvBqF,EAAKrF,MAAQoT,EAYjB,KAAK,GARDI,MAQKC,EAAI,EAAGA,EAAIhD,EAAU8C,QAAQlT,OAAQoT,IAAK,CAC/C,GAAIC,GAASjD,EAAU8C,QAAQE,EAC3BC,KAAWrO,GACXmO,EAAajN,KAAKmN,EAAOL,aAAPK,SAA0BJ,IAKpD,GAAIC,GAAU9C,EAAU8C,QAAQ7S,MAAM,EAItC,OAAOwB,cAAQyR,IAAIH,GAAcvT,KAAK,WAGlC,MAFAuQ,GAAOU,GAAKT,EAAUS,GAEfW,EAAuBrB,KAC/BvQ,KAAK,SAASiR,GAEb,MADAV,GAAOU,GAAKA,EACRa,EAAiBvB,EAAQnL,EAAK7B,eAAeR,SAEtC8O,EAAuBtB,GAE3BU,IACRjR,KAAK,SAASiR,GACbV,EAAOU,GAAKT,EAAUS,GAAKA,EAC3B7L,EAAKxB,QAAU2M,CAEf,KAAK,GAAIoD,GAAI,EAAGA,EAAIL,EAAQlT,OAAQuT,IAAK,CACrC,GAAIF,GAASH,EAAQK,EACjBF,KAAWrO,IACXqO,EAAO7P,QAAQqN,GAAKV,EAAOU,GAC3BwC,EAAO7P,QAAQb,QAAUwN,EAAOxN,YAMhD,QAAS6Q,GAAQtT,EAAK8D,GAClB,GAAIgB,GAAO7G,IAGQ,iBAAR+B,KACP8I,QAAQsI,KAAKpR,EACT,2CACJA,EAAMuT,OAAOvT,GAGjB,IAAIgE,GAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,QACdkQ,EAAQvD,EAAOU,GAAG9B,YAAYoB,EAAOzN,UAAW,YAC/CuM,YAAYkB,EAAOzN,WACpBiR,EAAMD,EAAMpE,IAAIpP,EAEpByT,GAAInE,UAAY,WACZ,GAAIhI,GAAQmM,EAAIrN,MACFsN,UAAVpM,IACAA,EAAQ,MAERsL,EAAetL,KACfA,EAAQkL,EAAYlL,IAExBrD,EAAQqD,IAGZmM,EAAIpE,QAAU,WACVnL,EAAOuP,EAAI/N,UAlBnBZ,SAoBSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EAIX,QAAS4P,GAAQlT,EAAUoD,GACvB,GAAIgB,GAAO7G,KAEP+F,EAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,QACdkQ,EAAQvD,EAAOU,GAAG9B,YAAYoB,EAAOzN,UAAW,YAC/CuM,YAAYkB,EAAOzN,WAEpBiR,EAAMD,EAAMK,aACZC,EAAkB,CAEtBL,GAAInE,UAAY,WACZ,GAAIyE,GAASN,EAAIrN,MAEjB,IAAI2N,EAAQ,CACR,GAAIzM,GAAQyM,EAAOzM,KACfsL,GAAetL,KACfA,EAAQkL,EAAYlL,GAExB,IAAIlB,GAAS1F,EAAS4G,EAAOyM,EAAO/T,IAChC8T,IAEW,UAAX1N,EACAnC,EAAQmC,GAER2N,oBAGJ9P,MAIRwP,EAAIpE,QAAU,WACVnL,EAAOuP,EAAI/N,UA9BnBZ,SAgCSZ,IAKb,QAFA,EAAAyP,cAAgB3P,EAASF,GAElBE,EAGX,QAASgQ,GAAQhU,EAAKsH,EAAOxD,GACzB,GAAIgB,GAAO7G,IAGQ,iBAAR+B,KACP8I,QAAQsI,KAAKpR,EACT,2CACJA,EAAMuT,OAAOvT,GAGjB,IAAIgE,GAAU,GAAArC,cAAY,SAASsC,EAASC,GACxC,GAAI+L,EACJnL,GAAKrF,QAAQC,KAAK,WAEd,MADAuQ,GAASnL,EAAKxB,QACVgE,YAAiBgD,MACVwF,EAAkBG,EAAOU,IAAIjR,KAAK,SAASuU,GAC9C,MAAIA,GACO3M,EAEJ0K,EAAY1K,KAGpBA,IACR5H,KAAK,SAAS4H,GACb,GAAIuH,GAAcoB,EAAOU,GAAG9B,YAAYoB,EAAOzN,UAAW,aACtDgR,EAAQ3E,EAAYE,YAAYkB,EAAOzN,UAM7B,QAAV8E,IACAA,EAAQoM,QAGZ7E,EAAYI,WAAa,WAOPyE,SAAVpM,IACAA,EAAQ,MAGZrD,EAAQqD,IAEZuH,EAAYgB,QAAUhB,EAAYQ,QAAU,WACxC,GAAI6E,GAAMT,EAAI/N,MAAQ+N,EAAI/N,MAAQ+N,EAAI5E,YAAYnJ,KAClDxB,GAAOgQ,GAGX,IAAIT,GAAMD,EAAMxE,IAAI1H,EAAOtH,KAzC/B8E,SA0CSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EAGX,QAASmQ,GAAWnU,EAAK8D,GACrB,GAAIgB,GAAO7G,IAGQ,iBAAR+B,KACP8I,QAAQsI,KAAKpR,EACT,2CACJA,EAAMuT,OAAOvT,GAGjB,IAAIgE,GAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,QACduL,EAAcoB,EAAOU,GAAG9B,YAAYoB,EAAOzN,UAAW,aACtDgR,EAAQ3E,EAAYE,YAAYkB,EAAOzN,WAOvCiR,EAAMD,YAAaxT,EACvB6O,GAAYI,WAAa,WACrBhL,KAGJ4K,EAAYQ,QAAU,WAClBnL,EAAOuP,EAAI/N,QAKfmJ,EAAYgB,QAAU,WAClB,GAAIqE,GAAMT,EAAI/N,MAAQ+N,EAAI/N,MAAQ+N,EAAI5E,YAAYnJ,KAClDxB,GAAOgQ,MAvBfpP,SAyBSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EAGX,QAASoQ,GAAMtQ,GACX,GAAIgB,GAAO7G,KAEP+F,EAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,QACduL,EAAcoB,EAAOU,GAAG9B,YAAYoB,EAAOzN,UAAW,aACtDgR,EAAQ3E,EAAYE,YAAYkB,EAAOzN,WACvCiR,EAAMD,EAAMY,OAEhBvF,GAAYI,WAAa,WACrBhL,KAGJ4K,EAAYgB,QAAUhB,EAAYQ,QAAU,WACxC,GAAI6E,GAAMT,EAAI/N,MAAQ+N,EAAI/N,MAAQ+N,EAAI5E,YAAYnJ,KAClDxB,GAAOgQ,MAZfpP,SAcSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EAGX,QAASlE,GAAOgE,GACZ,GAAIgB,GAAO7G,KAEP+F,EAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,QACdkQ,EAAQvD,EAAOU,GAAG9B,YAAYoB,EAAOzN,UAAW,YAC/CuM,YAAYkB,EAAOzN,WACpBiR,EAAMD,EAAMa,OAEhBZ,GAAInE,UAAY,WACZrL,EAAQwP,EAAIrN,SAGhBqN,EAAIpE,QAAU,WACVnL,EAAOuP,EAAI/N,UAXnBZ,SAaSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EAGX,QAAShE,GAAIsU,EAAGxQ,GACZ,GAAIgB,GAAO7G,KAEP+F,EAAU,GAAArC,cAAY,SAASsC,EAASC,GACxC,MAAQ,GAAJoQ,MACArQ,GAAQ,UAKZa,GAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,QACdkQ,EAAQvD,EAAOU,GAAG9B,YAAYoB,EAAOzN,UAAW,YAC/CuM,YAAYkB,EAAOzN,WAEpB+R,GAAW,EACXd,EAAMD,EAAMK,YAChBJ,GAAInE,UAAY,WACZ,GAAIyE,GAASN,EAAIrN,MACjB,OAAK2N,QAOK,IAANO,EAGArQ,EAAQ8P,EAAO/T,KAEVuU,EAODtQ,EAAQ8P,EAAO/T,MAJfuU,GAAW,EACXR,EAAOS,QAAQF,SAdnBrQ,GAAQ,OAsBhBwP,EAAIpE,QAAU,WACVnL,EAAOuP,EAAI/N,UAlCnBZ,SAoCSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EAGX,QAASyQ,GAAK3Q,GACV,GAAIgB,GAAO7G,KAEP+F,EAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,QACdkQ,EAAQvD,EAAOU,GAAG9B,YAAYoB,EAAOzN,UAAW,YAC/CuM,YAAYkB,EAAOzN,WAEpBiR,EAAMD,EAAMK,aACZY,IAEJhB,GAAInE,UAAY,WACZ,GAAIyE,GAASN,EAAIrN,MAEjB,OAAK2N,IAKLU,EAAKzO,KAAK+N,EAAO/T,SACjB+T,sBALI9P,GAAQwQ,IAQhBhB,EAAIpE,QAAU,WACVnL,EAAOuP,EAAI/N,UArBnBZ,SAuBSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,ETgMVnG,EAAQiB,YAAa,CSl4BtB,IASIiR,GACAI,EAVJlG,EAAA9L,EAAA,GTs4BKqL,EAAe5K,EAAuBqL,GSr4B3CyK,EAAAvW,EAAA,GTy4BK4S,EAAQnS,EAAuB8V,GSx4BpChT,EAAAvD,EAAA,GT44BKwD,EAAY/C,EAAuB8C,GS34BxCiT,EAAAxW,EAAA,GT+4BKwV,EAAoB/U,EAAuB+V,GS14B5C7F,EAA4B,mCA6rB5B8F,GACAzQ,QAAS,eACTsB,aAAcA,EACdmO,QAASA,EACTN,QAASA,EACTU,QAASA,EACTG,WAAYA,EACZC,MAAOA,EACPtU,OAAQA,EACRE,IAAKA,EACLyU,KAAMA,ETq4BT5W,cSn4Bc+W,ETo4Bd9W,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,EAASM,GAE/B,YAgBA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GUjmDxF,QAAS4G,GAAazC,GAClB,GAAI8B,GAAO7G,KACPgS,IACJ,IAAIjN,EACA,IAAK,GAAInD,KAAKmD,GACViN,EAAOpQ,GAAKmD,EAAQnD,EAa5B,OATAoQ,GAAO4E,UAAY5E,EAAO3N,KAAO,IAE7B2N,EAAOzN,YAAcsC,EAAK7B,eAAeT,YACzCyN,EAAO4E,WAAa5E,EAAOzN,UAAY,KAG3CsC,EAAKxB,QAAU2M,EACfA,EAAO6E,WAAPrT,aAEOE,aAAQsC,UAKnB,QAASmQ,GAAMtQ,GACX,GAAIgB,GAAO7G,KACP+F,EAAUc,EAAKrF,QAAQC,KAAK,WAG5B,IAAK,GAFDmV,GAAY/P,EAAKxB,QAAQuR,UAEpBhV,EAAIkV,aAAajV,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC/C,GAAIG,GAAM+U,aAAa/U,IAAIH,EAEI,KAA3BG,EAAIiH,QAAQ4N,IACZE,aAAaZ,WAAWnU,KAMpC,QADA,EAAA2T,cAAgB3P,EAASF,GAClBE,EAMX,QAASsP,GAAQtT,EAAK8D,GAClB,GAAIgB,GAAO7G,IAGQ,iBAAR+B,KACP8I,QAAQsI,KAAKpR,EACT,2CACJA,EAAMuT,OAAOvT,GAGjB,IAAIgE,GAAUc,EAAKrF,QAAQC,KAAK,WAC5B,GAAIuQ,GAASnL,EAAKxB,QACd8C,EAAS2O,aAAazB,QAAQrD,EAAO4E,UAAY7U,EAUrD,OAJIoG,KACAA,EAAS6J,EAAO6E,WAAW/L,YAAY3C,IAGpCA,GAIX,QADA,EAAAuN,cAAgB3P,EAASF,GAClBE,EAIX,QAAS4P,GAAQlT,EAAUoD,GACvB,GAAIgB,GAAO7G,KAEP+F,EAAUc,EAAKrF,QAAQC,KAAK,WAc5B,IAAK,GAbDuQ,GAASnL,EAAKxB,QACduR,EAAY5E,EAAO4E,UACnBG,EAAkBH,EAAU/U,OAC5BA,EAASiV,aAAajV,OAQtBgU,EAAkB,EAEbjU,EAAI,EAAOC,EAAJD,EAAYA,IAAK,CAC7B,GAAIG,GAAM+U,aAAa/U,IAAIH,EAC3B,IAA+B,IAA3BG,EAAIiH,QAAQ4N,GAAhB,CAGA,GAAIvN,GAAQyN,aAAazB,QAAQtT,EAajC,IAPIsH,IACAA,EAAQ2I,EAAO6E,WAAW/L,YAAYzB,IAG1CA,EAAQ5G,EAAS4G,EAAOtH,EAAIoH,UAAU4N,GAClClB,KAEU,SAAVxM,EACA,MAAOA,MAMnB,QADA,EAAAqM,cAAgB3P,EAASF,GAClBE,EAIX,QAAShE,GAAIsU,EAAGxQ,GACZ,GAAIgB,GAAO7G,KACP+F,EAAUc,EAAKrF,QAAQC,KAAK,WAC5B,GACI0G,GADA6J,EAASnL,EAAKxB,OAElB,KACI8C,EAAS2O,aAAa/U,IAAIsU,GAC5B,MAAO5O,GACLU,EAAS,KAQb,MAJIA,KACAA,EAASA,EAAOgB,UAAU6I,EAAO4E,UAAU/U,SAGxCsG,GAIX,QADA,EAAAuN,cAAgB3P,EAASF,GAClBE,EAGX,QAASyQ,GAAK3Q,GACV,GAAIgB,GAAO7G,KACP+F,EAAUc,EAAKrF,QAAQC,KAAK,WAK5B,IAAK,GAJDuQ,GAASnL,EAAKxB,QACdxD,EAASiV,aAAajV,OACtB2U,KAEK5U,EAAI,EAAOC,EAAJD,EAAYA,IAC8B,IAAlDkV,aAAa/U,IAAIH,GAAGoH,QAAQgJ,EAAO4E,YACnCJ,EAAKzO,KAAK+O,aAAa/U,IAAIH,GAAGuH,UAAU6I,EAAO4E,UAAU/U,QAIjE,OAAO2U,IAIX,QADA,EAAAd,cAAgB3P,EAASF,GAClBE,EAIX,QAASlE,GAAOgE,GACZ,GAAIgB,GAAO7G,KACP+F,EAAUc,EAAK2P,OAAO/U,KAAK,SAAS+U,GACpC,MAAOA,GAAK3U,QAIhB,QADA,EAAA6T,cAAgB3P,EAASF,GAClBE,EAIX,QAASmQ,GAAWnU,EAAK8D,GACrB,GAAIgB,GAAO7G,IAGQ,iBAAR+B,KACP8I,QAAQsI,KAAKpR,EACT,2CACJA,EAAMuT,OAAOvT,GAGjB,IAAIgE,GAAUc,EAAKrF,QAAQC,KAAK,WAC5B,GAAIuQ,GAASnL,EAAKxB,OAClByR,cAAaZ,WAAWlE,EAAO4E,UAAY7U,IAI/C,QADA,EAAA2T,cAAgB3P,EAASF,GAClBE,EAOX,QAASgQ,GAAQhU,EAAKsH,EAAOxD,GACzB,GAAIgB,GAAO7G,IAGQ,iBAAR+B,KACP8I,QAAQsI,KAAKpR,EACT,2CACJA,EAAMuT,OAAOvT,GAGjB,IAAIgE,GAAUc,EAAKrF,QAAQC,KAAK,WAGdgU,SAAVpM,IACAA,EAAQ,KAIZ,IAAI2N,GAAgB3N,CAEpB,OAAO,IAAA3F,cAAY,SAASsC,EAASC,GACjC,GAAI+L,GAASnL,EAAKxB,OAClB2M,GAAO6E,WAAWzN,UAAUC,EAAO,SAASA,EAAO5B,GAC/C,GAAIA,EACAxB,EAAOwB,OAEP,KACIqP,aAAaf,QAAQ/D,EAAO4E,UAAY7U,EAAKsH,GAC7CrD,EAAQgR,GACV,MAAOrQ,GAGU,uBAAXA,EAAEtC,MACS,+BAAXsC,EAAEtC,MACF4B,EAAOU,GAEXV,EAAOU,SAQ3B,QADA,EAAA+O,cAAgB3P,EAASF,GAClBE,EVi2CVnG,EAAQiB,YAAa,CUxlDtB,IAAA0C,GAAArD,EAAA,GV4lDKsD,EAAe7C,EAAuB4C,GU3lD3CE,EAAAvD,EAAA,GV+lDKwD,EAAY/C,EAAuB8C,GU9lDxCiT,EAAAxW,EAAA,GVkmDKwV,EAAoB/U,EAAuB+V,GU12C5CO,GACA/Q,QAAS,sBACTsB,aAAcA,EAEdmO,QAASA,EACTN,QAASA,EACTU,QAASA,EACTG,WAAYA,EACZC,MAAOA,EACPtU,OAAQA,EACRE,IAAKA,EACLyU,KAAMA,EVumDT5W,cUpmDcqX,EVqmDdpX,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,EAASM,GAE/B,YAgBA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GWz3DxF,QAAS4G,GAAazC,GAClB,GAAI8B,GAAO7G,KACPgS,GACAU,GAAI,KAGR,IAAI3N,EACA,IAAK,GAAInD,KAAKmD,GACViN,EAAOpQ,GAA4B,gBAAhBmD,GAAQnD,GACfmD,EAAQnD,GAAGiD,WAAaE,EAAQnD,EAIpD,IAAIsV,GAAgB,GAAAxT,cAAY,SAASsC,EAASC,GAG9C,IACI+L,EAAOU,GAAKyE,aAAanF,EAAO3N,KAAMiR,OAAOtD,EAAOxN,SAC3BwN,EAAO5N,YAAa4N,EAAO1N,MACtD,MAAOqC,GACL,MAAOV,GAAOU,GAIlBqL,EAAOU,GAAG9B,YAAY,SAASwG,GAC3BA,EAAEC,WAAW,8BAAgCrF,EAAOzN,UACvC,kDACA,WACTsC,EAAKxB,QAAU2M,EACfhM,KACD,SAASoR,EAAG3P,GACXxB,EAAOwB,QAMnB,OADAuK,GAAO6E,WAAPrT,aACO0T,EAGX,QAAS7B,GAAQtT,EAAK8D,GAClB,GAAIgB,GAAO7G,IAGQ,iBAAR+B,KACP8I,QAAQsI,KAAKpR,EACO,2CACpBA,EAAMuT,OAAOvT,GAGjB,IAAIgE,GAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,OAClB2M,GAAOU,GAAG9B,YAAY,SAASwG,GAC3BA,EAAEC,WAAW,iBAAmBrF,EAAOzN,UAC1B,0BAA2BxC,GAC3B,SAASqV,EAAGE,GACrB,GAAInP,GAASmP,EAAQC,KAAK1V,OACbyV,EAAQC,KAAKC,KAAK,GAAGnO,MAAQ,IAItClB,KACAA,EAAS6J,EAAO6E,WAAW/L,YAAY3C,IAG3CnC,EAAQmC,IACT,SAASiP,EAAG3P,GAEXxB,EAAOwB,SAlBnBZ,SAqBSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EAGX,QAAS4P,GAAQlT,EAAUoD,GACvB,GAAIgB,GAAO7G,KAEP+F,EAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,OAElB2M,GAAOU,GAAG9B,YAAY,SAASwG,GAC3BA,EAAEC,WAAW,iBAAmBrF,EAAOzN,aACnC,SAAS6S,EAAGE,GAIR,IAAK,GAHDC,GAAOD,EAAQC,KACf1V,EAAS0V,EAAK1V,OAETD,EAAI,EAAOC,EAAJD,EAAYA,IAAK,CAC7B,GAAI4V,GAAOD,EAAKC,KAAK5V,GACjBuG,EAASqP,EAAKnO,KAYlB,IARIlB,IACAA,EAAS6J,EAAO6E,WAAW/L,YAAY3C,IAG3CA,EAAS1F,EAAS0F,EAAQqP,EAAKzV,IAAKH,EAAI,GAIzB,SAAXuG,EAEA,WADAnC,GAAQmC,GAKhBnC,KACD,SAASoR,EAAG3P,GACXxB,EAAOwB,SA/BvBZ,SAkCSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EAGX,QAASgQ,GAAQhU,EAAKsH,EAAOxD,GACzB,GAAIgB,GAAO7G,IAGQ,iBAAR+B,KACP8I,QAAQsI,KAAKpR,EACO,2CACpBA,EAAMuT,OAAOvT,GAGjB,IAAIgE,GAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WAIAgU,SAAVpM,IACAA,EAAQ,KAIZ,IAAI2N,GAAgB3N,EAEhB2I,EAASnL,EAAKxB,OAClB2M,GAAO6E,WAAWzN,UAAUC,EAAO,SAASA,EAAO5B,GAC3CA,EACAxB,EAAOwB,GAEPuK,EAAOU,GAAG9B,YAAY,SAASwG,GAC3BA,EAAEC,WAAW,0BACArF,EAAOzN,UACP,+BACCxC,EAAKsH,GAAQ,WACvBrD,EAAQgR,IACT,SAASI,EAAG3P,GACXxB,EAAOwB,MAEZ,SAASgQ,GAGJA,EAASC,OAASD,EAASE,WAQ3B1R,EAAOwR,SApC3B5Q,SAyCSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EAGX,QAASmQ,GAAWnU,EAAK8D,GACrB,GAAIgB,GAAO7G,IAGQ,iBAAR+B,KACP8I,QAAQsI,KAAKpR,EACO,2CACpBA,EAAMuT,OAAOvT,GAGjB,IAAIgE,GAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,OAClB2M,GAAOU,GAAG9B,YAAY,SAASwG,GAC3BA,EAAEC,WAAW,eAAiBrF,EAAOzN,UACxB,kBAAmBxC,GACnB,WACTiE,KACD,SAASoR,EAAG3P,GAEXxB,EAAOwB,SATnBZ,SAYSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EAKX,QAASoQ,GAAMtQ,GACX,GAAIgB,GAAO7G,KAEP+F,EAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,OAClB2M,GAAOU,GAAG9B,YAAY,SAASwG,GAC3BA,EAAEC,WAAW,eAAiBrF,EAAOzN,aACxB,WACTyB,KACD,SAASoR,EAAG3P,GACXxB,EAAOwB,SAPnBZ,SAUSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EAKX,QAASlE,GAAOgE,GACZ,GAAIgB,GAAO7G,KAEP+F,EAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,OAClB2M,GAAOU,GAAG9B,YAAY,SAASwG,GAE3BA,EAAEC,WAAW,+BACArF,EAAOzN,aAAe,SAAS6S,EAAGE,GAC3C,GAAInP,GAASmP,EAAQC,KAAKC,KAAK,GAAG/W,CAElCuF,GAAQmC,IACT,SAASiP,EAAG3P,GAEXxB,EAAOwB,SAXnBZ,SAcSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EAUX,QAAShE,GAAIsU,EAAGxQ,GACZ,GAAIgB,GAAO7G,KAEP+F,EAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,OAClB2M,GAAOU,GAAG9B,YAAY,SAASwG,GAC3BA,EAAEC,WAAW,mBAAqBrF,EAAOzN,UAC5B,yBAA0B8R,EAAI,GAC9B,SAASe,EAAGE,GACrB,GAAInP,GAASmP,EAAQC,KAAK1V,OACbyV,EAAQC,KAAKC,KAAK,GAAGzV,IAAM,IACxCiE,GAAQmC,IACT,SAASiP,EAAG3P,GACXxB,EAAOwB,SAVnBZ,SAaSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EAGX,QAASyQ,GAAK3Q,GACV,GAAIgB,GAAO7G,KAEP+F,EAAU,GAAArC,cAAY,SAASsC,EAASC,GACxCY,EAAKrF,QAAQC,KAAK,WACd,GAAIuQ,GAASnL,EAAKxB,OAClB2M,GAAOU,GAAG9B,YAAY,SAASwG,GAC3BA,EAAEC,WAAW,mBAAqBrF,EAAOzN,aAC5B,SAAS6S,EAAGE,GAGrB,IAAK,GAFDd,MAEK5U,EAAI,EAAGA,EAAI0V,EAAQC,KAAK1V,OAAQD,IACrC4U,EAAKzO,KAAKuP,EAAQC,KAAKC,KAAK5V,GAAGG,IAGnCiE,GAAQwQ,IACT,SAASY,EAAG3P,GAEXxB,EAAOwB,SAdnBZ,SAiBSZ,IAIb,QADA,EAAAyP,cAAgB3P,EAASF,GAClBE,EX4iDVnG,EAAQiB,YAAa,CW13DtB,IAAA0C,GAAArD,EAAA,GX83DKsD,EAAe7C,EAAuB4C,GW73D3CE,EAAAvD,EAAA,GXi4DKwD,EAAY/C,EAAuB8C,GWh4DxCiT,EAAAxW,EAAA,GXo4DKwV,EAAoB/U,EAAuB+V,GWrjD5CkB,GACA1R,QAAS,gBACTsB,aAAcA,EACdmO,QAASA,EACTN,QAASA,EACTU,QAASA,EACTG,WAAYA,EACZC,MAAOA,EACPtU,OAAQA,EACRE,IAAKA,EACLyU,KAAMA,EXm3DT5W,cWh3DcgY,EXi3Dd/X,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,GAEtB,YYrtED,SAASiY,GAAoB9R,EAASF,EAAUC,GACpB,kBAAbD,IACPE,EAAQtE,KAAKoE,GAGY,kBAAlBC,IACPC,WAAcD,GZitErBlG,EAAQiB,YAAa,EAWrBjB,aYxtEciY,EZytEdhY,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,EAASM,GAE/B,YAQA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,Ga/uExF,QAASkX,KACL,IAGI,MAAIhF,cAYwB,mBAAjBqE,eAAqD,mBAAdY,YAC9CA,UAAUC,WACV,SAAS5M,KAAK2M,UAAUC,aAAe,SAAS5M,KAAK2M,UAAUC,YACxD,EAGJlF,cACiB,kBAAbA,cAAI9C,MAKY,mBAAhBiI,cAvBA,EAwBb,MAAOtR,GACL,OAAO,Gb2sEd/G,EAAQiB,YAAa,Ca3uEtB,IAAA4V,GAAAvW,EAAA,Gb+uEK4S,EAAQnS,EAAuB8V,EAmCnC7W,ca9uEckY,Eb+uEdjY,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,GAEtB,YczxED,SAASsY,KACL,IACI,MAA+B,mBAAjBpB,eACT,WAAaA,eACdA,aAAaf,QACnB,MAAOpP,GACL,OAAO,GdqxEd/G,EAAQiB,YAAa,EASrBjB,ac1xEcsY,Ed2xEdrY,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,GAEtB,Ye3yED,SAASuY,KACL,MAA+B,kBAAjBhB,cf4yEjBvX,EAAQiB,YAAa,EAKrBjB,ae9yEcuY,Ef+yEdtY,EAAOD,QAAUA,EAAQ,YAIpB,SAASC,EAAQD,EAASM,IgBvzEhC,SAAAkY,EAAAjK,GAAA,YAmDA,SAAAC,KACAd,GAAA,CAGA,KAFA,GAAA1L,GAAAyW,EACAvQ,EAAA0F,EAAA3L,OACAiG,GAAA,CAIA,IAHAuQ,EAAA7K,EACAA,KACA5L,EAAA,KACAA,EAAAkG,GACAuQ,EAAAzW,IAEAkG,GAAA0F,EAAA3L,OAEAyL,GAAA,EAIA,QAAAgL,GAAAC,GACA,IAAA/K,EAAAzF,KAAAwQ,IAAAjL,GACAkL,IArEA,GAEAA,GAFAC,EAAAL,EAAAM,kBAAAN,EAAAO,sBAIA,IAAAxK,EAAAI,QACA,GAAAkK,EAAA,CACA,GAAAG,GAAA,EACAC,EAAA,GAAAJ,GAAArK,GACA0K,EAAAV,EAAAW,SAAAC,eAAA,GACAH,GAAAI,QAAAH,GACAI,eAAA,IAEAV,EAAA,WACAM,EAAAzE,KAAAuE,MAAA,OAEG,IAAAR,EAAAe,cAAA,mBAAAf,GAAAgB,eAOHZ,EADG,YAAAJ,IAAA,sBAAAA,GAAAW,SAAAM,cAAA,UACH,WAIA,GAAAC,GAAAlB,EAAAW,SAAAM,cAAA,SACAC,GAAAnJ,mBAAA,WACA/B,IAEAkL,EAAAnJ,mBAAA,KACAmJ,EAAAC,WAAAC,YAAAF,GACAA,EAAA,MAEAlB,EAAAW,SAAAU,gBAAAC,YAAAJ,IAGA,WACA1L,WAAAQ,EAAA,QAvBG,CACH,GAAAuL,GAAA,GAAAvB,GAAAgB,cACAO,GAAAC,MAAAC,UAAAzL,EACAoK,EAAA,WACAmB,EAAAG,MAAAC,YAAA,QAuBAvB,GAAA,WACArK,EAAAC,YAIA,IAAAd,GACAE,IAkBA3N,GAAAD,QAAA0Y,IhBg0E8B/X,KAAKX,EAAU,WAAa,MAAOI,SAAYE,EAAoB,KAI3F,SAASL,EAAQD,EAASM,IiBv4EhC,SAAAiO,GAAA,YAIA,SAAA6L,MAeA,QAAA/R,GAAAgS,GACA,qBAAAA,GACA,SAAA/Y,WAAA,8BAEAlB,MAAAka,MAAAC,EACAna,KAAAwN,SACAxN,KAAAoa,QAAA,OAEAjM,EAAAI,UACAvO,KAAAqa,QAAAC,GAEAL,IAAAD,GACAO,EAAAva,KAAAia,GA4BA,QAAAO,GAAAzU,EAAA0U,EAAAC,GACA1a,KAAA+F,UACA,kBAAA0U,KACAza,KAAAya,cACAza,KAAA2a,cAAA3a,KAAA4a,oBAEA,kBAAAF,KACA1a,KAAA0a,aACA1a,KAAA6a,aAAA7a,KAAA8a,mBAgBA,QAAAC,GAAAhV,EAAAiV,EAAA3R,GACAiP,EAAA,WACA,GAAA2C,EACA,KACAA,EAAAD,EAAA3R,GACK,MAAA1C,GACL,MAAAuU,GAAAjV,OAAAF,EAAAY,GAEAsU,IAAAlV,EACAmV,EAAAjV,OAAAF,EAAA,GAAA7E,WAAA,uCAEAga,EAAAlV,QAAAD,EAAAkV,KA8CA,QAAAE,GAAAva,GAEA,GAAAa,GAAAb,KAAAa,IACA,OAAAb,IAAA,gBAAAA,IAAA,kBAAAa,GACA,WACAA,EAAAC,MAAAd,EAAAW,YAFA,OAOA,QAAAgZ,GAAA1T,EAAAuU,GAGA,QAAAC,GAAAhS,GACAuP,IAGAA,GAAA,EACAsC,EAAAjV,OAAAY,EAAAwC,IAGA,QAAAiS,GAAAjS,GACAuP,IAGAA,GAAA,EACAsC,EAAAlV,QAAAa,EAAAwC,IAGA,QAAAkS,KACAH,EAAAE,EAAAD,GAlBA,GAAAzC,IAAA,EAqBAzQ,EAAAqT,EAAAD,EACA,WAAApT,EAAAkI,QACAgL,EAAAlT,EAAAkB,OAIA,QAAAmS,GAAAR,EAAA3R,GACA,GAAAoS,KACA,KACAA,EAAApS,MAAA2R,EAAA3R,GACAoS,EAAApL,OAAA,UACG,MAAA1J,GACH8U,EAAApL,OAAA,QACAoL,EAAApS,MAAA1C,EAEA,MAAA8U,GAIA,QAAAzV,GAAAqD,GACA,MAAAA,aAAArJ,MACAqJ,EAEA6R,EAAAlV,QAAA,GAAAhG,MAAAga,GAAA3Q,GAIA,QAAApD,GAAAyV,GACA,GAAA3V,GAAA,GAAA/F,MAAAga,EACA,OAAAkB,GAAAjV,OAAAF,EAAA2V,GAIA,QAAAvG,GAAAwG,GAqBA,QAAAC,GAAAvS,EAAAzH,GAOA,QAAAia,GAAAC,GACAC,EAAAna,GAAAka,IACAE,IAAAlU,GAAA8Q,IACAA,GAAA,EACAsC,EAAAlV,QAAAD,EAAAgW,IAVAlV,EAAAb,QAAAqD,GAAA5H,KAAAoa,EAAA,SAAApU,GACAmR,IACAA,GAAA,EACAsC,EAAAjV,OAAAF,EAAA0B,MAxBA,GAAAZ,GAAA7G,IACA,uBAAA2E,OAAAC,UAAAC,SAAAtE,KAAAob,GACA,MAAA3b,MAAAiG,OAAA,GAAA/E,WAAA,oBAGA,IAAA4G,GAAA6T,EAAA9Z,OACA+W,GAAA,CACA,KAAA9Q,EACA,MAAA9H,MAAAgG,WAQA,KALA,GAAA+V,GAAA,GAAArX,OAAAoD,GACAkU,EAAA,EACApa,EAAA,GACAmE,EAAA,GAAA/F,MAAAga,KAEApY,EAAAkG,GACA8T,EAAAD,EAAA/Z,KAEA,OAAAmE,GAmBA,QAAAkW,GAAAN,GAmBA,QAAA1B,GAAA5Q,GACAxC,EAAAb,QAAAqD,GAAA5H,KAAA,SAAA6O,GACAsI,IACAA,GAAA,EACAsC,EAAAlV,QAAAD,EAAAuK,KAEK,SAAA7I,GACLmR,IACAA,GAAA,EACAsC,EAAAjV,OAAAF,EAAA0B,MA3BA,GAAAZ,GAAA7G,IACA,uBAAA2E,OAAAC,UAAAC,SAAAtE,KAAAob,GACA,MAAA3b,MAAAiG,OAAA,GAAA/E,WAAA,oBAGA,IAAA4G,GAAA6T,EAAA9Z,OACA+W,GAAA,CACA,KAAA9Q,EACA,MAAA9H,MAAAgG,WAMA,KAHA,GAAApE,GAAA,GACAmE,EAAA,GAAA/F,MAAAga,KAEApY,EAAAkG,GACAmS,EAAA0B,EAAA/Z,GAEA,OAAAmE,GAtQA,GAAAuS,GAAApY,EAAA,IAKAgb,KAEAgB,GAAA,YACAC,GAAA,aACAhC,GAAA,UAEA,KAAAhM,EAAAI,QAEA,GAAA+L,IAAA,YAGAza,GAAAD,UAAAqI,EAkBAA,EAAArD,UAAAqD,SAAA,SAAAyS,GACA,MAAA1a,MAAAyB,KAAA,KAAAiZ,IAEAzS,EAAArD,UAAAnD,KAAA,SAAAgZ,EAAAC,GACA,qBAAAD,IAAAza,KAAAka,QAAAiC,GACA,kBAAAzB,IAAA1a,KAAAka,QAAAgC,EACA,MAAAlc,KAEA,IAAA+F,GAAA,GAAA/F,MAAA0C,YAAAsX,EAOA,IALA7L,EAAAI,SACAvO,KAAAqa,UAAAC,IACAta,KAAAqa,QAAA,MAGAra,KAAAka,QAAAC,EAAA,CACA,GAAAF,GAAAja,KAAAka,QAAAiC,EAAA1B,EAAAC,CACAK,GAAAhV,EAAAkU,EAAAja,KAAAoa,aAEApa,MAAAwN,MAAAzF,KAAA,GAAAyS,GAAAzU,EAAA0U,EAAAC,GAGA,OAAA3U,IAaAyU,EAAA5V,UAAA+V,cAAA,SAAAtR,GACA6R,EAAAlV,QAAAhG,KAAA+F,QAAAsD,IAEAmR,EAAA5V,UAAAgW,mBAAA,SAAAvR,GACA0R,EAAA/a,KAAA+F,QAAA/F,KAAAya,YAAApR,IAEAmR,EAAA5V,UAAAiW,aAAA,SAAAxR,GACA6R,EAAAjV,OAAAjG,KAAA+F,QAAAsD,IAEAmR,EAAA5V,UAAAkW,kBAAA,SAAAzR,GACA0R,EAAA/a,KAAA+F,QAAA/F,KAAA0a,WAAArR,IAmBA6R,EAAAlV,QAAA,SAAAa,EAAAwC,GACA,GAAAlB,GAAAqT,EAAAL,EAAA9R,EACA,cAAAlB,EAAAkI,OACA,MAAA6K,GAAAjV,OAAAY,EAAAsB,EAAAkB,MAEA,IAAA+R,GAAAjT,EAAAkB,KAEA,IAAA+R,EACAb,EAAA1T,EAAAuU,OACG,CACHvU,EAAAqT,MAAAiC,EACAtV,EAAAuT,QAAA/Q,CAGA,KAFA,GAAAzH,GAAA,GACAkG,EAAAjB,EAAA2G,MAAA3L,SACAD,EAAAkG,GACAjB,EAAA2G,MAAA5L,GAAA+Y,cAAAtR,GAGA,MAAAxC,IAEAqU,EAAAjV,OAAA,SAAAY,EAAAY,GACAZ,EAAAqT,MAAAgC,EACArV,EAAAuT,QAAA3S,EAEA0G,EAAAI,SACA1H,EAAAwT,UAAAC,GACAhC,EAAA,WACAzR,EAAAwT,UAAAC,GACAnM,EAAAc,KAAA,qBAAAxH,EAAAZ,IAOA,KAFA,GAAAjF,GAAA,GACAkG,EAAAjB,EAAA2G,MAAA3L,SACAD,EAAAkG,GACAjB,EAAA2G,MAAA5L,GAAAiZ,aAAApT,EAEA,OAAAZ,IAsDAjH,EAAAoG,UAQApG,EAAAqG,SAMArG,EAAAuV,MAuCAvV,EAAAqc,SjB46E8B1b,KAAKX,EAASM,EAAoB,KAI1D,SAASL,EAAQD,EAASM,IkBpqFhC,SAAAkY,GAAA,YACA,mBAAAA,GAAAnQ,UACAmQ,EAAAnQ,QAAA/H,EAAA,OlByqF8BK,KAAKX,EAAU,WAAa,MAAOI","file":"localforage.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"localforage\"] = factory();\n\telse\n\t\troot[\"localforage\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"localforage\"] = factory();\n\telse\n\t\troot[\"localforage\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _isIndexedDBValid = __webpack_require__(11);\n\t\n\tvar _isIndexedDBValid2 = _interopRequireDefault(_isIndexedDBValid);\n\t\n\tvar _isWebSQLValid = __webpack_require__(13);\n\t\n\tvar _isWebSQLValid2 = _interopRequireDefault(_isWebSQLValid);\n\t\n\tvar _isLocalStorageValid = __webpack_require__(12);\n\t\n\tvar _isLocalStorageValid2 = _interopRequireDefault(_isLocalStorageValid);\n\t\n\tvar _indexeddb = __webpack_require__(7);\n\t\n\tvar _indexeddb2 = _interopRequireDefault(_indexeddb);\n\t\n\tvar _websql = __webpack_require__(9);\n\t\n\tvar _websql2 = _interopRequireDefault(_websql);\n\t\n\tvar _localstorage = __webpack_require__(8);\n\t\n\tvar _localstorage2 = _interopRequireDefault(_localstorage);\n\t\n\tvar _serializer = __webpack_require__(3);\n\t\n\tvar _serializer2 = _interopRequireDefault(_serializer);\n\t\n\tvar _promise = __webpack_require__(1);\n\t\n\tvar _promise2 = _interopRequireDefault(_promise);\n\t\n\tvar _executeTwoCallbacks = __webpack_require__(10);\n\t\n\tvar _executeTwoCallbacks2 = _interopRequireDefault(_executeTwoCallbacks);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// Custom drivers are stored here when `defineDriver()` is called.\n\t// They are shared across all instances of localForage.\n\tvar CustomDrivers = {};\n\t\n\tvar DriverType = {\n\t    INDEXEDDB: 'asyncStorage',\n\t    LOCALSTORAGE: 'localStorageWrapper',\n\t    WEBSQL: 'webSQLStorage'\n\t};\n\t\n\tvar DefaultDriverOrder = [DriverType.INDEXEDDB, DriverType.WEBSQL, DriverType.LOCALSTORAGE];\n\t\n\tvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'];\n\t\n\tvar DefaultConfig = {\n\t    description: '',\n\t    driver: DefaultDriverOrder.slice(),\n\t    name: 'localforage',\n\t    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n\t    // we can use without a prompt.\n\t    size: 4980736,\n\t    storeName: 'keyvaluepairs',\n\t    version: 1.0\n\t};\n\t\n\tvar driverSupport = {};\n\t// Check to see if IndexedDB is available and if it is the latest\n\t// implementation; it's our preferred backend library. We use \"_spec_test\"\n\t// as the name of the database because it's not the one we'll operate on,\n\t// but it's useful to make sure its using the right spec.\n\t// See: https://github.com/mozilla/localForage/issues/128\n\tdriverSupport[DriverType.INDEXEDDB] = (0, _isIndexedDBValid2.default)();\n\t\n\tdriverSupport[DriverType.WEBSQL] = (0, _isWebSQLValid2.default)();\n\t\n\tdriverSupport[DriverType.LOCALSTORAGE] = (0, _isLocalStorageValid2.default)();\n\t\n\tvar isArray = Array.isArray || function (arg) {\n\t    return Object.prototype.toString.call(arg) === '[object Array]';\n\t};\n\t\n\tfunction callWhenReady(localForageInstance, libraryMethod) {\n\t    localForageInstance[libraryMethod] = function () {\n\t        var _args = arguments;\n\t        return localForageInstance.ready().then(function () {\n\t            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n\t        });\n\t    };\n\t}\n\t\n\tfunction extend() {\n\t    for (var i = 1; i < arguments.length; i++) {\n\t        var arg = arguments[i];\n\t\n\t        if (arg) {\n\t            for (var key in arg) {\n\t                if (arg.hasOwnProperty(key)) {\n\t                    if (isArray(arg[key])) {\n\t                        arguments[0][key] = arg[key].slice();\n\t                    } else {\n\t                        arguments[0][key] = arg[key];\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    return arguments[0];\n\t}\n\t\n\tfunction isLibraryDriver(driverName) {\n\t    for (var driver in DriverType) {\n\t        if (DriverType.hasOwnProperty(driver) && DriverType[driver] === driverName) {\n\t            return true;\n\t        }\n\t    }\n\t\n\t    return false;\n\t}\n\t\n\tvar LocalForage = function () {\n\t    function LocalForage(options) {\n\t        _classCallCheck(this, LocalForage);\n\t\n\t        this.INDEXEDDB = DriverType.INDEXEDDB;\n\t        this.LOCALSTORAGE = DriverType.LOCALSTORAGE;\n\t        this.WEBSQL = DriverType.WEBSQL;\n\t\n\t        this._defaultConfig = extend({}, DefaultConfig);\n\t        this._config = extend({}, this._defaultConfig, options);\n\t        this._driverSet = null;\n\t        this._initDriver = null;\n\t        this._ready = false;\n\t        this._dbInfo = null;\n\t\n\t        this._wrapLibraryMethodsWithReady();\n\t        this.setDriver(this._config.driver);\n\t    }\n\t\n\t    // Set any config values for localForage; can be called anytime before\n\t    // the first API call (e.g. `getItem`, `setItem`).\n\t    // We loop through options so we don't overwrite existing config\n\t    // values.\n\t\n\t\n\t    LocalForage.prototype.config = function config(options) {\n\t        // If the options argument is an object, we use it to set values.\n\t        // Otherwise, we return either a specified config value or all\n\t        // config values.\n\t        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n\t            // If localforage is ready and fully initialized, we can't set\n\t            // any new configuration values. Instead, we return an error.\n\t            if (this._ready) {\n\t                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n\t            }\n\t\n\t            for (var i in options) {\n\t                if (i === 'storeName') {\n\t                    options[i] = options[i].replace(/\\W/g, '_');\n\t                }\n\t\n\t                this._config[i] = options[i];\n\t            }\n\t\n\t            // after all config options are set and\n\t            // the driver option is used, try setting it\n\t            if ('driver' in options && options.driver) {\n\t                this.setDriver(this._config.driver);\n\t            }\n\t\n\t            return true;\n\t        } else if (typeof options === 'string') {\n\t            return this._config[options];\n\t        } else {\n\t            return this._config;\n\t        }\n\t    };\n\t\n\t    // Used to define a custom driver, shared across all instances of\n\t    // localForage.\n\t\n\t\n\t    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n\t        var promise = new _promise2.default(function (resolve, reject) {\n\t            try {\n\t                var driverName = driverObject._driver;\n\t                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n\t                var namingError = new Error('Custom driver name already in use: ' + driverObject._driver);\n\t\n\t                // A driver name should be defined and not overlap with the\n\t                // library-defined, default drivers.\n\t                if (!driverObject._driver) {\n\t                    reject(complianceError);\n\t                    return;\n\t                }\n\t                if (isLibraryDriver(driverObject._driver)) {\n\t                    reject(namingError);\n\t                    return;\n\t                }\n\t\n\t                var customDriverMethods = LibraryMethods.concat('_initStorage');\n\t                for (var i = 0; i < customDriverMethods.length; i++) {\n\t                    var customDriverMethod = customDriverMethods[i];\n\t                    if (!customDriverMethod || !driverObject[customDriverMethod] || typeof driverObject[customDriverMethod] !== 'function') {\n\t                        reject(complianceError);\n\t                        return;\n\t                    }\n\t                }\n\t\n\t                var supportPromise = _promise2.default.resolve(true);\n\t                if ('_support' in driverObject) {\n\t                    if (driverObject._support && typeof driverObject._support === 'function') {\n\t                        supportPromise = driverObject._support();\n\t                    } else {\n\t                        supportPromise = _promise2.default.resolve(!!driverObject._support);\n\t                    }\n\t                }\n\t\n\t                supportPromise.then(function (supportResult) {\n\t                    driverSupport[driverName] = supportResult;\n\t                    CustomDrivers[driverName] = driverObject;\n\t                    resolve();\n\t                }, reject);\n\t            } catch (e) {\n\t                reject(e);\n\t            }\n\t        });\n\t\n\t        (0, _executeTwoCallbacks2.default)(promise, callback, errorCallback);\n\t        return promise;\n\t    };\n\t\n\t    LocalForage.prototype.driver = function driver() {\n\t        return this._driver || null;\n\t    };\n\t\n\t    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n\t        var self = this;\n\t        var getDriverPromise = _promise2.default.resolve().then(function () {\n\t            if (isLibraryDriver(driverName)) {\n\t                switch (driverName) {\n\t                    case self.INDEXEDDB:\n\t                        return _indexeddb2.default;\n\t                    case self.LOCALSTORAGE:\n\t                        return _localstorage2.default;\n\t                    case self.WEBSQL:\n\t                        return _websql2.default;\n\t                }\n\t            } else if (CustomDrivers[driverName]) {\n\t                return CustomDrivers[driverName];\n\t            } else {\n\t                throw new Error('Driver not found.');\n\t            }\n\t        });\n\t        (0, _executeTwoCallbacks2.default)(getDriverPromise, callback, errorCallback);\n\t        return getDriverPromise;\n\t    };\n\t\n\t    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n\t        var serializerPromise = _promise2.default.resolve(_serializer2.default);\n\t        (0, _executeTwoCallbacks2.default)(serializerPromise, callback);\n\t        return serializerPromise;\n\t    };\n\t\n\t    LocalForage.prototype.ready = function ready(callback) {\n\t        var self = this;\n\t\n\t        var promise = self._driverSet.then(function () {\n\t            if (self._ready === null) {\n\t                self._ready = self._initDriver();\n\t            }\n\t\n\t            return self._ready;\n\t        });\n\t\n\t        (0, _executeTwoCallbacks2.default)(promise, callback, callback);\n\t        return promise;\n\t    };\n\t\n\t    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n\t        var self = this;\n\t\n\t        if (!isArray(drivers)) {\n\t            drivers = [drivers];\n\t        }\n\t\n\t        var supportedDrivers = this._getSupportedDrivers(drivers);\n\t\n\t        function setDriverToConfig() {\n\t            self._config.driver = self.driver();\n\t        }\n\t\n\t        function initDriver(supportedDrivers) {\n\t            return function () {\n\t                var currentDriverIndex = 0;\n\t\n\t                function driverPromiseLoop() {\n\t                    while (currentDriverIndex < supportedDrivers.length) {\n\t                        var driverName = supportedDrivers[currentDriverIndex];\n\t                        currentDriverIndex++;\n\t\n\t                        self._dbInfo = null;\n\t                        self._ready = null;\n\t\n\t                        return self.getDriver(driverName).then(function (driver) {\n\t                            self._extend(driver);\n\t                            setDriverToConfig();\n\t\n\t                            self._ready = self._initStorage(self._config);\n\t                            return self._ready;\n\t                        }).catch(driverPromiseLoop);\n\t                    }\n\t\n\t                    setDriverToConfig();\n\t                    var error = new Error('No available storage method found.');\n\t                    self._driverSet = _promise2.default.reject(error);\n\t                    return self._driverSet;\n\t                }\n\t\n\t                return driverPromiseLoop();\n\t            };\n\t        }\n\t\n\t        // There might be a driver initialization in progress\n\t        // so wait for it to finish in order to avoid a possible\n\t        // race condition to set _dbInfo\n\t        var oldDriverSetDone = this._driverSet !== null ? this._driverSet.catch(function () {\n\t            return _promise2.default.resolve();\n\t        }) : _promise2.default.resolve();\n\t\n\t        this._driverSet = oldDriverSetDone.then(function () {\n\t            var driverName = supportedDrivers[0];\n\t            self._dbInfo = null;\n\t            self._ready = null;\n\t\n\t            return self.getDriver(driverName).then(function (driver) {\n\t                self._driver = driver._driver;\n\t                setDriverToConfig();\n\t                self._wrapLibraryMethodsWithReady();\n\t                self._initDriver = initDriver(supportedDrivers);\n\t            });\n\t        }).catch(function () {\n\t            setDriverToConfig();\n\t            var error = new Error('No available storage method found.');\n\t            self._driverSet = _promise2.default.reject(error);\n\t            return self._driverSet;\n\t        });\n\t\n\t        (0, _executeTwoCallbacks2.default)(this._driverSet, callback, errorCallback);\n\t        return this._driverSet;\n\t    };\n\t\n\t    LocalForage.prototype.supports = function supports(driverName) {\n\t        return !!driverSupport[driverName];\n\t    };\n\t\n\t    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n\t        extend(this, libraryMethodsAndProperties);\n\t    };\n\t\n\t    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n\t        var supportedDrivers = [];\n\t        for (var i = 0, len = drivers.length; i < len; i++) {\n\t            var driverName = drivers[i];\n\t            if (this.supports(driverName)) {\n\t                supportedDrivers.push(driverName);\n\t            }\n\t        }\n\t        return supportedDrivers;\n\t    };\n\t\n\t    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n\t        // Add a stub for each driver API method that delays the call to the\n\t        // corresponding driver method until localForage is ready. These stubs\n\t        // will be replaced by the driver methods as soon as the driver is\n\t        // loaded, so there is no performance impact.\n\t        for (var i = 0; i < LibraryMethods.length; i++) {\n\t            callWhenReady(this, LibraryMethods[i]);\n\t        }\n\t    };\n\t\n\t    LocalForage.prototype.createInstance = function createInstance(options) {\n\t        return new LocalForage(options);\n\t    };\n\t\n\t    return LocalForage;\n\t}();\n\t\n\t// The actual localForage object that we expose as a module or via a\n\t// global. It's extended by pulling in one of our other libraries.\n\t\n\t\n\texports.default = new LocalForage();\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t// This is CommonJS because lie is an external dependency, so Rollup\n\t// can just ignore it.\n\t__webpack_require__(16);\n\texports.default = Promise;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\tfunction executeCallback(promise, callback) {\n\t    if (callback) {\n\t        promise.then(function (result) {\n\t            callback(null, result);\n\t        }, function (error) {\n\t            callback(error);\n\t        });\n\t    }\n\t}\n\t\n\texports.default = executeCallback;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _createBlob = __webpack_require__(4);\n\t\n\tvar _createBlob2 = _interopRequireDefault(_createBlob);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n\t// it to Base64, so this is how we store it to prevent very strange errors with less\n\t// verbose ways of binary <-> string data storage.\n\tvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\n\tvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\n\tvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\t\n\tvar SERIALIZED_MARKER = '__lfsc__:';\n\tvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\t\n\t// OMG the serializations!\n\tvar TYPE_ARRAYBUFFER = 'arbf';\n\tvar TYPE_BLOB = 'blob';\n\tvar TYPE_INT8ARRAY = 'si08';\n\tvar TYPE_UINT8ARRAY = 'ui08';\n\tvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\n\tvar TYPE_INT16ARRAY = 'si16';\n\tvar TYPE_INT32ARRAY = 'si32';\n\tvar TYPE_UINT16ARRAY = 'ur16';\n\tvar TYPE_UINT32ARRAY = 'ui32';\n\tvar TYPE_FLOAT32ARRAY = 'fl32';\n\tvar TYPE_FLOAT64ARRAY = 'fl64';\n\tvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\t\n\tfunction stringToBuffer(serializedString) {\n\t    // Fill the string into a ArrayBuffer.\n\t    var bufferLength = serializedString.length * 0.75;\n\t    var len = serializedString.length;\n\t    var i;\n\t    var p = 0;\n\t    var encoded1, encoded2, encoded3, encoded4;\n\t\n\t    if (serializedString[serializedString.length - 1] === '=') {\n\t        bufferLength--;\n\t        if (serializedString[serializedString.length - 2] === '=') {\n\t            bufferLength--;\n\t        }\n\t    }\n\t\n\t    var buffer = new ArrayBuffer(bufferLength);\n\t    var bytes = new Uint8Array(buffer);\n\t\n\t    for (i = 0; i < len; i += 4) {\n\t        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n\t        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n\t        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n\t        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\t\n\t        /*jslint bitwise: true */\n\t        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n\t        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n\t        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n\t    }\n\t    return buffer;\n\t}\n\t\n\t// Converts a buffer to a string to store, serialized, in the backend\n\t// storage library.\n\tfunction bufferToString(buffer) {\n\t    // base64-arraybuffer\n\t    var bytes = new Uint8Array(buffer);\n\t    var base64String = '';\n\t    var i;\n\t\n\t    for (i = 0; i < bytes.length; i += 3) {\n\t        /*jslint bitwise: true */\n\t        base64String += BASE_CHARS[bytes[i] >> 2];\n\t        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n\t        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n\t        base64String += BASE_CHARS[bytes[i + 2] & 63];\n\t    }\n\t\n\t    if (bytes.length % 3 === 2) {\n\t        base64String = base64String.substring(0, base64String.length - 1) + '=';\n\t    } else if (bytes.length % 3 === 1) {\n\t        base64String = base64String.substring(0, base64String.length - 2) + '==';\n\t    }\n\t\n\t    return base64String;\n\t}\n\t\n\t// Serialize a value, afterwards executing a callback (which usually\n\t// instructs the `setItem()` callback/promise to be executed). This is how\n\t// we store binary data with localStorage.\n\tfunction serialize(value, callback) {\n\t    var valueString = '';\n\t    if (value) {\n\t        valueString = value.toString();\n\t    }\n\t\n\t    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n\t    // checks fail when running the tests using casper.js...\n\t    //\n\t    // TODO: See why those tests fail and use a better solution.\n\t    if (value && (value.toString() === '[object ArrayBuffer]' || value.buffer && value.buffer.toString() === '[object ArrayBuffer]')) {\n\t        // Convert binary arrays to a string and prefix the string with\n\t        // a special marker.\n\t        var buffer;\n\t        var marker = SERIALIZED_MARKER;\n\t\n\t        if (value instanceof ArrayBuffer) {\n\t            buffer = value;\n\t            marker += TYPE_ARRAYBUFFER;\n\t        } else {\n\t            buffer = value.buffer;\n\t\n\t            if (valueString === '[object Int8Array]') {\n\t                marker += TYPE_INT8ARRAY;\n\t            } else if (valueString === '[object Uint8Array]') {\n\t                marker += TYPE_UINT8ARRAY;\n\t            } else if (valueString === '[object Uint8ClampedArray]') {\n\t                marker += TYPE_UINT8CLAMPEDARRAY;\n\t            } else if (valueString === '[object Int16Array]') {\n\t                marker += TYPE_INT16ARRAY;\n\t            } else if (valueString === '[object Uint16Array]') {\n\t                marker += TYPE_UINT16ARRAY;\n\t            } else if (valueString === '[object Int32Array]') {\n\t                marker += TYPE_INT32ARRAY;\n\t            } else if (valueString === '[object Uint32Array]') {\n\t                marker += TYPE_UINT32ARRAY;\n\t            } else if (valueString === '[object Float32Array]') {\n\t                marker += TYPE_FLOAT32ARRAY;\n\t            } else if (valueString === '[object Float64Array]') {\n\t                marker += TYPE_FLOAT64ARRAY;\n\t            } else {\n\t                callback(new Error('Failed to get type for BinaryArray'));\n\t            }\n\t        }\n\t\n\t        callback(marker + bufferToString(buffer));\n\t    } else if (valueString === '[object Blob]') {\n\t        // Conver the blob to a binaryArray and then to a string.\n\t        var fileReader = new FileReader();\n\t\n\t        fileReader.onload = function () {\n\t            // Backwards-compatible prefix for the blob type.\n\t            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\t\n\t            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n\t        };\n\t\n\t        fileReader.readAsArrayBuffer(value);\n\t    } else {\n\t        try {\n\t            callback(JSON.stringify(value));\n\t        } catch (e) {\n\t            console.error(\"Couldn't convert value into a JSON string: \", value);\n\t\n\t            callback(null, e);\n\t        }\n\t    }\n\t}\n\t\n\t// Deserialize data we've inserted into a value column/field. We place\n\t// special markers into our strings to mark them as encoded; this isn't\n\t// as nice as a meta field, but it's the only sane thing we can do whilst\n\t// keeping localStorage support intact.\n\t//\n\t// Oftentimes this will just deserialize JSON content, but if we have a\n\t// special marker (SERIALIZED_MARKER, defined above), we will extract\n\t// some kind of arraybuffer/binary data/typed array out of the string.\n\tfunction deserialize(value) {\n\t    // If we haven't marked this string as being specially serialized (i.e.\n\t    // something other than serialized JSON), we can just return it and be\n\t    // done with it.\n\t    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n\t        return JSON.parse(value);\n\t    }\n\t\n\t    // The following code deals with deserializing some kind of Blob or\n\t    // TypedArray. First we separate out the type of data we're dealing\n\t    // with from the data itself.\n\t    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n\t    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\t\n\t    var blobType;\n\t    // Backwards-compatible blob type serialization strategy.\n\t    // DBs created with older versions of localForage will simply not have the blob type.\n\t    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n\t        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n\t        blobType = matcher[1];\n\t        serializedString = serializedString.substring(matcher[0].length);\n\t    }\n\t    var buffer = stringToBuffer(serializedString);\n\t\n\t    // Return the right type based on the code/type set during\n\t    // serialization.\n\t    switch (type) {\n\t        case TYPE_ARRAYBUFFER:\n\t            return buffer;\n\t        case TYPE_BLOB:\n\t            return (0, _createBlob2.default)([buffer], { type: blobType });\n\t        case TYPE_INT8ARRAY:\n\t            return new Int8Array(buffer);\n\t        case TYPE_UINT8ARRAY:\n\t            return new Uint8Array(buffer);\n\t        case TYPE_UINT8CLAMPEDARRAY:\n\t            return new Uint8ClampedArray(buffer);\n\t        case TYPE_INT16ARRAY:\n\t            return new Int16Array(buffer);\n\t        case TYPE_UINT16ARRAY:\n\t            return new Uint16Array(buffer);\n\t        case TYPE_INT32ARRAY:\n\t            return new Int32Array(buffer);\n\t        case TYPE_UINT32ARRAY:\n\t            return new Uint32Array(buffer);\n\t        case TYPE_FLOAT32ARRAY:\n\t            return new Float32Array(buffer);\n\t        case TYPE_FLOAT64ARRAY:\n\t            return new Float64Array(buffer);\n\t        default:\n\t            throw new Error('Unknown type: ' + type);\n\t    }\n\t}\n\t\n\tvar localforageSerializer = {\n\t    serialize: serialize,\n\t    deserialize: deserialize,\n\t    stringToBuffer: stringToBuffer,\n\t    bufferToString: bufferToString\n\t};\n\t\n\texports.default = localforageSerializer;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t// Abstracts constructing a Blob object, so it also works in older\n\t// browsers that don't support the native Blob constructor. (i.e.\n\t// old QtWebKit versions, at least).\n\t// Abstracts constructing a Blob object, so it also works in older\n\t// browsers that don't support the native Blob constructor. (i.e.\n\t// old QtWebKit versions, at least).\n\tfunction createBlob(parts, properties) {\n\t    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n\t    parts = parts || [];\n\t    properties = properties || {};\n\t    try {\n\t        return new Blob(parts, properties);\n\t    } catch (e) {\n\t        if (e.name !== 'TypeError') {\n\t            throw e;\n\t        }\n\t        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n\t        var builder = new Builder();\n\t        for (var i = 0; i < parts.length; i += 1) {\n\t            builder.append(parts[i]);\n\t        }\n\t        return builder.getBlob(properties.type);\n\t    }\n\t}\n\t\n\texports.default = createBlob;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\tfunction getIDB() {\n\t    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n\t    if (typeof indexedDB !== 'undefined') {\n\t        return indexedDB;\n\t    }\n\t    if (typeof webkitIndexedDB !== 'undefined') {\n\t        return webkitIndexedDB;\n\t    }\n\t    if (typeof mozIndexedDB !== 'undefined') {\n\t        return mozIndexedDB;\n\t    }\n\t    if (typeof OIndexedDB !== 'undefined') {\n\t        return OIndexedDB;\n\t    }\n\t    if (typeof msIndexedDB !== 'undefined') {\n\t        return msIndexedDB;\n\t    }\n\t}\n\t\n\tvar idb = getIDB();\n\texports.default = idb;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _createBlob = __webpack_require__(4);\n\t\n\tvar _createBlob2 = _interopRequireDefault(_createBlob);\n\t\n\tvar _idb = __webpack_require__(5);\n\t\n\tvar _idb2 = _interopRequireDefault(_idb);\n\t\n\tvar _promise = __webpack_require__(1);\n\t\n\tvar _promise2 = _interopRequireDefault(_promise);\n\t\n\tvar _executeCallback = __webpack_require__(2);\n\t\n\tvar _executeCallback2 = _interopRequireDefault(_executeCallback);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// Some code originally from async_storage.js in\n\t// [Gaia](https://github.com/mozilla-b2g/gaia).\n\t\n\tvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\n\tvar supportsBlobs;\n\tvar dbContexts;\n\t\n\t// Transform a binary string to an array buffer, because otherwise\n\t// weird stuff happens when you try to work with the binary string directly.\n\t// It is known.\n\t// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n\t// encode-decode-image-with-base64-breaks-image (2013-04-21)\n\tfunction _binStringToArrayBuffer(bin) {\n\t    var length = bin.length;\n\t    var buf = new ArrayBuffer(length);\n\t    var arr = new Uint8Array(buf);\n\t    for (var i = 0; i < length; i++) {\n\t        arr[i] = bin.charCodeAt(i);\n\t    }\n\t    return buf;\n\t}\n\t\n\t// Fetch a blob using ajax. This reveals bugs in Chrome < 43.\n\t// For details on all this junk:\n\t// https://github.com/nolanlawson/state-of-binary-data-in-the-browser#readme\n\tfunction _blobAjax(url) {\n\t    return new _promise2.default(function (resolve, reject) {\n\t        var xhr = new XMLHttpRequest();\n\t        xhr.open('GET', url);\n\t        xhr.withCredentials = true;\n\t        xhr.responseType = 'arraybuffer';\n\t\n\t        xhr.onreadystatechange = function () {\n\t            if (xhr.readyState !== 4) {\n\t                return;\n\t            }\n\t            if (xhr.status === 200) {\n\t                return resolve({\n\t                    response: xhr.response,\n\t                    type: xhr.getResponseHeader('Content-Type')\n\t                });\n\t            }\n\t            reject({ status: xhr.status, response: xhr.response });\n\t        };\n\t        xhr.send();\n\t    });\n\t}\n\t\n\t//\n\t// Detect blob support. Chrome didn't support it until version 38.\n\t// In version 37 they had a broken version where PNGs (and possibly\n\t// other binary types) aren't stored correctly, because when you fetch\n\t// them, the content type is always null.\n\t//\n\t// Furthermore, they have some outstanding bugs where blobs occasionally\n\t// are read by FileReader as null, or by ajax as 404s.\n\t//\n\t// Sadly we use the 404 bug to detect the FileReader bug, so if they\n\t// get fixed independently and released in different versions of Chrome,\n\t// then the bug could come back. So it's worthwhile to watch these issues:\n\t// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n\t// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n\t//\n\tfunction _checkBlobSupportWithoutCaching(idb) {\n\t    return new _promise2.default(function (resolve, reject) {\n\t        var blob = (0, _createBlob2.default)([''], { type: 'image/png' });\n\t        var txn = idb.transaction([DETECT_BLOB_SUPPORT_STORE], 'readwrite');\n\t        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\t        txn.oncomplete = function () {\n\t            // have to do it in a separate transaction, else the correct\n\t            // content type is always returned\n\t            var blobTxn = idb.transaction([DETECT_BLOB_SUPPORT_STORE], 'readwrite');\n\t            var getBlobReq = blobTxn.objectStore(DETECT_BLOB_SUPPORT_STORE).get('key');\n\t            getBlobReq.onerror = reject;\n\t            getBlobReq.onsuccess = function (e) {\n\t\n\t                var storedBlob = e.target.result;\n\t                var url = URL.createObjectURL(storedBlob);\n\t\n\t                _blobAjax(url).then(function (res) {\n\t                    resolve(!!(res && res.type === 'image/png'));\n\t                }, function () {\n\t                    resolve(false);\n\t                }).then(function () {\n\t                    URL.revokeObjectURL(url);\n\t                });\n\t            };\n\t        };\n\t        txn.onerror = txn.onabort = reject;\n\t    }).catch(function () {\n\t        return false; // error, so assume unsupported\n\t    });\n\t}\n\t\n\tfunction _checkBlobSupport(idb) {\n\t    if (typeof supportsBlobs === 'boolean') {\n\t        return _promise2.default.resolve(supportsBlobs);\n\t    }\n\t    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n\t        supportsBlobs = value;\n\t        return supportsBlobs;\n\t    });\n\t}\n\t\n\tfunction _deferReadiness(dbInfo) {\n\t    var dbContext = dbContexts[dbInfo.name];\n\t\n\t    // Create a deferred object representing the current database operation.\n\t    var deferredOperation = {};\n\t\n\t    deferredOperation.promise = new _promise2.default(function (resolve) {\n\t        deferredOperation.resolve = resolve;\n\t    });\n\t\n\t    // Enqueue the deferred operation.\n\t    dbContext.deferredOperations.push(deferredOperation);\n\t\n\t    // Chain its promise to the database readiness.\n\t    if (!dbContext.dbReady) {\n\t        dbContext.dbReady = deferredOperation.promise;\n\t    } else {\n\t        dbContext.dbReady = dbContext.dbReady.then(function () {\n\t            return deferredOperation.promise;\n\t        });\n\t    }\n\t}\n\t\n\tfunction _advanceReadiness(dbInfo) {\n\t    var dbContext = dbContexts[dbInfo.name];\n\t\n\t    // Dequeue a deferred operation.\n\t    var deferredOperation = dbContext.deferredOperations.pop();\n\t\n\t    // Resolve its promise (which is part of the database readiness\n\t    // chain of promises).\n\t    if (deferredOperation) {\n\t        deferredOperation.resolve();\n\t    }\n\t}\n\t\n\tfunction _getConnection(dbInfo, upgradeNeeded) {\n\t    return new _promise2.default(function (resolve, reject) {\n\t\n\t        if (dbInfo.db) {\n\t            if (upgradeNeeded) {\n\t                _deferReadiness(dbInfo);\n\t                dbInfo.db.close();\n\t            } else {\n\t                return resolve(dbInfo.db);\n\t            }\n\t        }\n\t\n\t        var dbArgs = [dbInfo.name];\n\t\n\t        if (upgradeNeeded) {\n\t            dbArgs.push(dbInfo.version);\n\t        }\n\t\n\t        var openreq = _idb2.default.open.apply(_idb2.default, dbArgs);\n\t\n\t        if (upgradeNeeded) {\n\t            openreq.onupgradeneeded = function (e) {\n\t                var db = openreq.result;\n\t                try {\n\t                    db.createObjectStore(dbInfo.storeName);\n\t                    if (e.oldVersion <= 1) {\n\t                        // Added when support for blob shims was added\n\t                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\t                    }\n\t                } catch (ex) {\n\t                    if (ex.name === 'ConstraintError') {\n\t                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n\t                    } else {\n\t                        throw ex;\n\t                    }\n\t                }\n\t            };\n\t        }\n\t\n\t        openreq.onerror = function () {\n\t            reject(openreq.error);\n\t        };\n\t\n\t        openreq.onsuccess = function () {\n\t            resolve(openreq.result);\n\t            _advanceReadiness(dbInfo);\n\t        };\n\t    });\n\t}\n\t\n\tfunction _getOriginalConnection(dbInfo) {\n\t    return _getConnection(dbInfo, false);\n\t}\n\t\n\tfunction _getUpgradedConnection(dbInfo) {\n\t    return _getConnection(dbInfo, true);\n\t}\n\t\n\tfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n\t    if (!dbInfo.db) {\n\t        return true;\n\t    }\n\t\n\t    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n\t    var isDowngrade = dbInfo.version < dbInfo.db.version;\n\t    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\t\n\t    if (isDowngrade) {\n\t        // If the version is not the default one\n\t        // then warn for impossible downgrade.\n\t        if (dbInfo.version !== defaultVersion) {\n\t            console.warn('The database \"' + dbInfo.name + '\"' + ' can\\'t be downgraded from version ' + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n\t        }\n\t        // Align the versions to prevent errors.\n\t        dbInfo.version = dbInfo.db.version;\n\t    }\n\t\n\t    if (isUpgrade || isNewStore) {\n\t        // If the store is new then increment the version (if needed).\n\t        // This will trigger an \"upgradeneeded\" event which is required\n\t        // for creating a store.\n\t        if (isNewStore) {\n\t            var incVersion = dbInfo.db.version + 1;\n\t            if (incVersion > dbInfo.version) {\n\t                dbInfo.version = incVersion;\n\t            }\n\t        }\n\t\n\t        return true;\n\t    }\n\t\n\t    return false;\n\t}\n\t\n\t// encode a blob for indexeddb engines that don't support blobs\n\tfunction _encodeBlob(blob) {\n\t    return new _promise2.default(function (resolve, reject) {\n\t        var reader = new FileReader();\n\t        reader.onerror = reject;\n\t        reader.onloadend = function (e) {\n\t            var base64 = btoa(e.target.result || '');\n\t            resolve({\n\t                __local_forage_encoded_blob: true,\n\t                data: base64,\n\t                type: blob.type\n\t            });\n\t        };\n\t        reader.readAsBinaryString(blob);\n\t    });\n\t}\n\t\n\t// decode an encoded blob\n\tfunction _decodeBlob(encodedBlob) {\n\t    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n\t    return (0, _createBlob2.default)([arrayBuff], { type: encodedBlob.type });\n\t}\n\t\n\t// is this one of our fancy encoded blobs?\n\tfunction _isEncodedBlob(value) {\n\t    return value && value.__local_forage_encoded_blob;\n\t}\n\t\n\t// Specialize the default `ready()` function by making it dependent\n\t// on the current database operations. Thus, the driver will be actually\n\t// ready when it's been initialized (default) *and* there are no pending\n\t// operations on the database (initiated by some other instances).\n\tfunction _fullyReady(callback) {\n\t    var self = this;\n\t\n\t    var promise = self._initReady().then(function () {\n\t        var dbContext = dbContexts[self._dbInfo.name];\n\t\n\t        if (dbContext && dbContext.dbReady) {\n\t            return dbContext.dbReady;\n\t        }\n\t    });\n\t\n\t    promise.then(callback, callback);\n\t    return promise;\n\t}\n\t\n\t// Open the IndexedDB database (automatically creates one if one didn't\n\t// previously exist), using any options set in the config.\n\tfunction _initStorage(options) {\n\t    var self = this;\n\t    var dbInfo = {\n\t        db: null\n\t    };\n\t\n\t    if (options) {\n\t        for (var i in options) {\n\t            dbInfo[i] = options[i];\n\t        }\n\t    }\n\t\n\t    // Initialize a singleton container for all running localForages.\n\t    if (!dbContexts) {\n\t        dbContexts = {};\n\t    }\n\t\n\t    // Get the current context of the database;\n\t    var dbContext = dbContexts[dbInfo.name];\n\t\n\t    // ...or create a new context.\n\t    if (!dbContext) {\n\t        dbContext = {\n\t            // Running localForages sharing a database.\n\t            forages: [],\n\t            // Shared database.\n\t            db: null,\n\t            // Database readiness (promise).\n\t            dbReady: null,\n\t            // Deferred operations on the database.\n\t            deferredOperations: []\n\t        };\n\t        // Register the new context in the global container.\n\t        dbContexts[dbInfo.name] = dbContext;\n\t    }\n\t\n\t    // Register itself as a running localForage in the current context.\n\t    dbContext.forages.push(self);\n\t\n\t    // Replace the default `ready()` function with the specialized one.\n\t    if (!self._initReady) {\n\t        self._initReady = self.ready;\n\t        self.ready = _fullyReady;\n\t    }\n\t\n\t    // Create an array of initialization states of the related localForages.\n\t    var initPromises = [];\n\t\n\t    function ignoreErrors() {\n\t        // Don't handle errors here,\n\t        // just makes sure related localForages aren't pending.\n\t        return _promise2.default.resolve();\n\t    }\n\t\n\t    for (var j = 0; j < dbContext.forages.length; j++) {\n\t        var forage = dbContext.forages[j];\n\t        if (forage !== self) {\n\t            // Don't wait for itself...\n\t            initPromises.push(forage._initReady().catch(ignoreErrors));\n\t        }\n\t    }\n\t\n\t    // Take a snapshot of the related localForages.\n\t    var forages = dbContext.forages.slice(0);\n\t\n\t    // Initialize the connection process only when\n\t    // all the related localForages aren't pending.\n\t    return _promise2.default.all(initPromises).then(function () {\n\t        dbInfo.db = dbContext.db;\n\t        // Get the connection or open a new one without upgrade.\n\t        return _getOriginalConnection(dbInfo);\n\t    }).then(function (db) {\n\t        dbInfo.db = db;\n\t        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n\t            // Reopen the database for upgrading.\n\t            return _getUpgradedConnection(dbInfo);\n\t        }\n\t        return db;\n\t    }).then(function (db) {\n\t        dbInfo.db = dbContext.db = db;\n\t        self._dbInfo = dbInfo;\n\t        // Share the final connection amongst related localForages.\n\t        for (var k = 0; k < forages.length; k++) {\n\t            var forage = forages[k];\n\t            if (forage !== self) {\n\t                // Self is already up-to-date.\n\t                forage._dbInfo.db = dbInfo.db;\n\t                forage._dbInfo.version = dbInfo.version;\n\t            }\n\t        }\n\t    });\n\t}\n\t\n\tfunction getItem(key, callback) {\n\t    var self = this;\n\t\n\t    // Cast the key to a string, as that's all we can set as a key.\n\t    if (typeof key !== 'string') {\n\t        console.warn(key + ' used as a key, but it is not a string.');\n\t        key = String(key);\n\t    }\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\t            var req = store.get(key);\n\t\n\t            req.onsuccess = function () {\n\t                var value = req.result;\n\t                if (value === undefined) {\n\t                    value = null;\n\t                }\n\t                if (_isEncodedBlob(value)) {\n\t                    value = _decodeBlob(value);\n\t                }\n\t                resolve(value);\n\t            };\n\t\n\t            req.onerror = function () {\n\t                reject(req.error);\n\t            };\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Iterate over all items stored in database.\n\tfunction iterate(iterator, callback) {\n\t    var self = this;\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\t\n\t            var req = store.openCursor();\n\t            var iterationNumber = 1;\n\t\n\t            req.onsuccess = function () {\n\t                var cursor = req.result;\n\t\n\t                if (cursor) {\n\t                    var value = cursor.value;\n\t                    if (_isEncodedBlob(value)) {\n\t                        value = _decodeBlob(value);\n\t                    }\n\t                    var result = iterator(value, cursor.key, iterationNumber++);\n\t\n\t                    if (result !== void 0) {\n\t                        resolve(result);\n\t                    } else {\n\t                        cursor.continue();\n\t                    }\n\t                } else {\n\t                    resolve();\n\t                }\n\t            };\n\t\n\t            req.onerror = function () {\n\t                reject(req.error);\n\t            };\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t\n\t    return promise;\n\t}\n\t\n\tfunction setItem(key, value, callback) {\n\t    var self = this;\n\t\n\t    // Cast the key to a string, as that's all we can set as a key.\n\t    if (typeof key !== 'string') {\n\t        console.warn(key + ' used as a key, but it is not a string.');\n\t        key = String(key);\n\t    }\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        var dbInfo;\n\t        self.ready().then(function () {\n\t            dbInfo = self._dbInfo;\n\t            if (value instanceof Blob) {\n\t                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n\t                    if (blobSupport) {\n\t                        return value;\n\t                    }\n\t                    return _encodeBlob(value);\n\t                });\n\t            }\n\t            return value;\n\t        }).then(function (value) {\n\t            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n\t            var store = transaction.objectStore(dbInfo.storeName);\n\t\n\t            // The reason we don't _save_ null is because IE 10 does\n\t            // not support saving the `null` type in IndexedDB. How\n\t            // ironic, given the bug below!\n\t            // See: https://github.com/mozilla/localForage/issues/161\n\t            if (value === null) {\n\t                value = undefined;\n\t            }\n\t\n\t            transaction.oncomplete = function () {\n\t                // Cast to undefined so the value passed to\n\t                // callback/promise is the same as what one would get out\n\t                // of `getItem()` later. This leads to some weirdness\n\t                // (setItem('foo', undefined) will return `null`), but\n\t                // it's not my fault localStorage is our baseline and that\n\t                // it's weird.\n\t                if (value === undefined) {\n\t                    value = null;\n\t                }\n\t\n\t                resolve(value);\n\t            };\n\t            transaction.onabort = transaction.onerror = function () {\n\t                var err = req.error ? req.error : req.transaction.error;\n\t                reject(err);\n\t            };\n\t\n\t            var req = store.put(value, key);\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction removeItem(key, callback) {\n\t    var self = this;\n\t\n\t    // Cast the key to a string, as that's all we can set as a key.\n\t    if (typeof key !== 'string') {\n\t        console.warn(key + ' used as a key, but it is not a string.');\n\t        key = String(key);\n\t    }\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n\t            var store = transaction.objectStore(dbInfo.storeName);\n\t\n\t            // We use a Grunt task to make this safe for IE and some\n\t            // versions of Android (including those used by Cordova).\n\t            // Normally IE won't like `.delete()` and will insist on\n\t            // using `['delete']()`, but we have a build step that\n\t            // fixes this for us now.\n\t            var req = store.delete(key);\n\t            transaction.oncomplete = function () {\n\t                resolve();\n\t            };\n\t\n\t            transaction.onerror = function () {\n\t                reject(req.error);\n\t            };\n\t\n\t            // The request will be also be aborted if we've exceeded our storage\n\t            // space.\n\t            transaction.onabort = function () {\n\t                var err = req.error ? req.error : req.transaction.error;\n\t                reject(err);\n\t            };\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction clear(callback) {\n\t    var self = this;\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n\t            var store = transaction.objectStore(dbInfo.storeName);\n\t            var req = store.clear();\n\t\n\t            transaction.oncomplete = function () {\n\t                resolve();\n\t            };\n\t\n\t            transaction.onabort = transaction.onerror = function () {\n\t                var err = req.error ? req.error : req.transaction.error;\n\t                reject(err);\n\t            };\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction length(callback) {\n\t    var self = this;\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\t            var req = store.count();\n\t\n\t            req.onsuccess = function () {\n\t                resolve(req.result);\n\t            };\n\t\n\t            req.onerror = function () {\n\t                reject(req.error);\n\t            };\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction key(n, callback) {\n\t    var self = this;\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        if (n < 0) {\n\t            resolve(null);\n\t\n\t            return;\n\t        }\n\t\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\t\n\t            var advanced = false;\n\t            var req = store.openCursor();\n\t            req.onsuccess = function () {\n\t                var cursor = req.result;\n\t                if (!cursor) {\n\t                    // this means there weren't enough keys\n\t                    resolve(null);\n\t\n\t                    return;\n\t                }\n\t\n\t                if (n === 0) {\n\t                    // We have the first key, return it if that's what they\n\t                    // wanted.\n\t                    resolve(cursor.key);\n\t                } else {\n\t                    if (!advanced) {\n\t                        // Otherwise, ask the cursor to skip ahead n\n\t                        // records.\n\t                        advanced = true;\n\t                        cursor.advance(n);\n\t                    } else {\n\t                        // When we get here, we've got the nth key.\n\t                        resolve(cursor.key);\n\t                    }\n\t                }\n\t            };\n\t\n\t            req.onerror = function () {\n\t                reject(req.error);\n\t            };\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction keys(callback) {\n\t    var self = this;\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly').objectStore(dbInfo.storeName);\n\t\n\t            var req = store.openCursor();\n\t            var keys = [];\n\t\n\t            req.onsuccess = function () {\n\t                var cursor = req.result;\n\t\n\t                if (!cursor) {\n\t                    resolve(keys);\n\t                    return;\n\t                }\n\t\n\t                keys.push(cursor.key);\n\t                cursor.continue();\n\t            };\n\t\n\t            req.onerror = function () {\n\t                reject(req.error);\n\t            };\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\tvar asyncStorage = {\n\t    _driver: 'asyncStorage',\n\t    _initStorage: _initStorage,\n\t    iterate: iterate,\n\t    getItem: getItem,\n\t    setItem: setItem,\n\t    removeItem: removeItem,\n\t    clear: clear,\n\t    length: length,\n\t    key: key,\n\t    keys: keys\n\t};\n\texports.default = asyncStorage;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _serializer = __webpack_require__(3);\n\t\n\tvar _serializer2 = _interopRequireDefault(_serializer);\n\t\n\tvar _promise = __webpack_require__(1);\n\t\n\tvar _promise2 = _interopRequireDefault(_promise);\n\t\n\tvar _executeCallback = __webpack_require__(2);\n\t\n\tvar _executeCallback2 = _interopRequireDefault(_executeCallback);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// Config the localStorage backend, using options set in the config.\n\tfunction _initStorage(options) {\n\t    var self = this;\n\t    var dbInfo = {};\n\t    if (options) {\n\t        for (var i in options) {\n\t            dbInfo[i] = options[i];\n\t        }\n\t    }\n\t\n\t    dbInfo.keyPrefix = dbInfo.name + '/';\n\t\n\t    if (dbInfo.storeName !== self._defaultConfig.storeName) {\n\t        dbInfo.keyPrefix += dbInfo.storeName + '/';\n\t    }\n\t\n\t    self._dbInfo = dbInfo;\n\t    dbInfo.serializer = _serializer2.default;\n\t\n\t    return _promise2.default.resolve();\n\t}\n\t\n\t// Remove all keys from the datastore, effectively destroying all data in\n\t// the app's key/value store!\n\t// If IndexedDB isn't available, we'll fall back to localStorage.\n\t// Note that this will have considerable performance and storage\n\t// side-effects (all data will be serialized on save and only data that\n\t// can be converted to a string via `JSON.stringify()` will be saved).\n\t\n\tfunction clear(callback) {\n\t    var self = this;\n\t    var promise = self.ready().then(function () {\n\t        var keyPrefix = self._dbInfo.keyPrefix;\n\t\n\t        for (var i = localStorage.length - 1; i >= 0; i--) {\n\t            var key = localStorage.key(i);\n\t\n\t            if (key.indexOf(keyPrefix) === 0) {\n\t                localStorage.removeItem(key);\n\t            }\n\t        }\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Retrieve an item from the store. Unlike the original async_storage\n\t// library in Gaia, we don't modify return values at all. If a key's value\n\t// is `undefined`, we pass that value to the callback function.\n\tfunction getItem(key, callback) {\n\t    var self = this;\n\t\n\t    // Cast the key to a string, as that's all we can set as a key.\n\t    if (typeof key !== 'string') {\n\t        console.warn(key + ' used as a key, but it is not a string.');\n\t        key = String(key);\n\t    }\n\t\n\t    var promise = self.ready().then(function () {\n\t        var dbInfo = self._dbInfo;\n\t        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\t\n\t        // If a result was found, parse it from the serialized\n\t        // string into a JS object. If result isn't truthy, the key\n\t        // is likely undefined and we'll pass it straight to the\n\t        // callback.\n\t        if (result) {\n\t            result = dbInfo.serializer.deserialize(result);\n\t        }\n\t\n\t        return result;\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Iterate over all items in the store.\n\tfunction iterate(iterator, callback) {\n\t    var self = this;\n\t\n\t    var promise = self.ready().then(function () {\n\t        var dbInfo = self._dbInfo;\n\t        var keyPrefix = dbInfo.keyPrefix;\n\t        var keyPrefixLength = keyPrefix.length;\n\t        var length = localStorage.length;\n\t\n\t        // We use a dedicated iterator instead of the `i` variable below\n\t        // so other keys we fetch in localStorage aren't counted in\n\t        // the `iterationNumber` argument passed to the `iterate()`\n\t        // callback.\n\t        //\n\t        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n\t        var iterationNumber = 1;\n\t\n\t        for (var i = 0; i < length; i++) {\n\t            var key = localStorage.key(i);\n\t            if (key.indexOf(keyPrefix) !== 0) {\n\t                continue;\n\t            }\n\t            var value = localStorage.getItem(key);\n\t\n\t            // If a result was found, parse it from the serialized\n\t            // string into a JS object. If result isn't truthy, the\n\t            // key is likely undefined and we'll pass it straight\n\t            // to the iterator.\n\t            if (value) {\n\t                value = dbInfo.serializer.deserialize(value);\n\t            }\n\t\n\t            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\t\n\t            if (value !== void 0) {\n\t                return value;\n\t            }\n\t        }\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Same as localStorage's key() method, except takes a callback.\n\tfunction key(n, callback) {\n\t    var self = this;\n\t    var promise = self.ready().then(function () {\n\t        var dbInfo = self._dbInfo;\n\t        var result;\n\t        try {\n\t            result = localStorage.key(n);\n\t        } catch (error) {\n\t            result = null;\n\t        }\n\t\n\t        // Remove the prefix from the key, if a key is found.\n\t        if (result) {\n\t            result = result.substring(dbInfo.keyPrefix.length);\n\t        }\n\t\n\t        return result;\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction keys(callback) {\n\t    var self = this;\n\t    var promise = self.ready().then(function () {\n\t        var dbInfo = self._dbInfo;\n\t        var length = localStorage.length;\n\t        var keys = [];\n\t\n\t        for (var i = 0; i < length; i++) {\n\t            if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {\n\t                keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));\n\t            }\n\t        }\n\t\n\t        return keys;\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Supply the number of keys in the datastore to the callback function.\n\tfunction length(callback) {\n\t    var self = this;\n\t    var promise = self.keys().then(function (keys) {\n\t        return keys.length;\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Remove an item from the store, nice and simple.\n\tfunction removeItem(key, callback) {\n\t    var self = this;\n\t\n\t    // Cast the key to a string, as that's all we can set as a key.\n\t    if (typeof key !== 'string') {\n\t        console.warn(key + ' used as a key, but it is not a string.');\n\t        key = String(key);\n\t    }\n\t\n\t    var promise = self.ready().then(function () {\n\t        var dbInfo = self._dbInfo;\n\t        localStorage.removeItem(dbInfo.keyPrefix + key);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Set a key's value and run an optional callback once the value is set.\n\t// Unlike Gaia's implementation, the callback function is passed the value,\n\t// in case you want to operate on that value only after you're sure it\n\t// saved, or something like that.\n\tfunction setItem(key, value, callback) {\n\t    var self = this;\n\t\n\t    // Cast the key to a string, as that's all we can set as a key.\n\t    if (typeof key !== 'string') {\n\t        console.warn(key + ' used as a key, but it is not a string.');\n\t        key = String(key);\n\t    }\n\t\n\t    var promise = self.ready().then(function () {\n\t        // Convert undefined values to null.\n\t        // https://github.com/mozilla/localForage/pull/42\n\t        if (value === undefined) {\n\t            value = null;\n\t        }\n\t\n\t        // Save the original value to pass to the callback.\n\t        var originalValue = value;\n\t\n\t        return new _promise2.default(function (resolve, reject) {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.serializer.serialize(value, function (value, error) {\n\t                if (error) {\n\t                    reject(error);\n\t                } else {\n\t                    try {\n\t                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n\t                        resolve(originalValue);\n\t                    } catch (e) {\n\t                        // localStorage capacity exceeded.\n\t                        // TODO: Make this a specific error/event.\n\t                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n\t                            reject(e);\n\t                        }\n\t                        reject(e);\n\t                    }\n\t                }\n\t            });\n\t        });\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\tvar localStorageWrapper = {\n\t    _driver: 'localStorageWrapper',\n\t    _initStorage: _initStorage,\n\t    // Default API, from Gaia/localStorage.\n\t    iterate: iterate,\n\t    getItem: getItem,\n\t    setItem: setItem,\n\t    removeItem: removeItem,\n\t    clear: clear,\n\t    length: length,\n\t    key: key,\n\t    keys: keys\n\t};\n\t\n\texports.default = localStorageWrapper;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _serializer = __webpack_require__(3);\n\t\n\tvar _serializer2 = _interopRequireDefault(_serializer);\n\t\n\tvar _promise = __webpack_require__(1);\n\t\n\tvar _promise2 = _interopRequireDefault(_promise);\n\t\n\tvar _executeCallback = __webpack_require__(2);\n\t\n\tvar _executeCallback2 = _interopRequireDefault(_executeCallback);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/*\n\t * Includes code from:\n\t *\n\t * base64-arraybuffer\n\t * https://github.com/niklasvh/base64-arraybuffer\n\t *\n\t * Copyright (c) 2012 Niklas von Hertzen\n\t * Licensed under the MIT license.\n\t */\n\t// Open the WebSQL database (automatically creates one if one didn't\n\t// previously exist), using any options set in the config.\n\tfunction _initStorage(options) {\n\t    var self = this;\n\t    var dbInfo = {\n\t        db: null\n\t    };\n\t\n\t    if (options) {\n\t        for (var i in options) {\n\t            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n\t        }\n\t    }\n\t\n\t    var dbInfoPromise = new _promise2.default(function (resolve, reject) {\n\t        // Open the database; the openDatabase API will automatically\n\t        // create it for us if it doesn't exist.\n\t        try {\n\t            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n\t        } catch (e) {\n\t            return reject(e);\n\t        }\n\t\n\t        // Create our key/value table if it doesn't exist.\n\t        dbInfo.db.transaction(function (t) {\n\t            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' (id INTEGER PRIMARY KEY, key unique, value)', [], function () {\n\t                self._dbInfo = dbInfo;\n\t                resolve();\n\t            }, function (t, error) {\n\t                reject(error);\n\t            });\n\t        });\n\t    });\n\t\n\t    dbInfo.serializer = _serializer2.default;\n\t    return dbInfoPromise;\n\t}\n\t\n\tfunction getItem(key, callback) {\n\t    var self = this;\n\t\n\t    // Cast the key to a string, as that's all we can set as a key.\n\t    if (typeof key !== 'string') {\n\t        console.warn(key + ' used as a key, but it is not a string.');\n\t        key = String(key);\n\t    }\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.db.transaction(function (t) {\n\t                t.executeSql('SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n\t                    var result = results.rows.length ? results.rows.item(0).value : null;\n\t\n\t                    // Check to see if this is serialized content we need to\n\t                    // unpack.\n\t                    if (result) {\n\t                        result = dbInfo.serializer.deserialize(result);\n\t                    }\n\t\n\t                    resolve(result);\n\t                }, function (t, error) {\n\t\n\t                    reject(error);\n\t                });\n\t            });\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction iterate(iterator, callback) {\n\t    var self = this;\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t\n\t            dbInfo.db.transaction(function (t) {\n\t                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n\t                    var rows = results.rows;\n\t                    var length = rows.length;\n\t\n\t                    for (var i = 0; i < length; i++) {\n\t                        var item = rows.item(i);\n\t                        var result = item.value;\n\t\n\t                        // Check to see if this is serialized content\n\t                        // we need to unpack.\n\t                        if (result) {\n\t                            result = dbInfo.serializer.deserialize(result);\n\t                        }\n\t\n\t                        result = iterator(result, item.key, i + 1);\n\t\n\t                        // void(0) prevents problems with redefinition\n\t                        // of `undefined`.\n\t                        if (result !== void 0) {\n\t                            resolve(result);\n\t                            return;\n\t                        }\n\t                    }\n\t\n\t                    resolve();\n\t                }, function (t, error) {\n\t                    reject(error);\n\t                });\n\t            });\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction setItem(key, value, callback) {\n\t    var self = this;\n\t\n\t    // Cast the key to a string, as that's all we can set as a key.\n\t    if (typeof key !== 'string') {\n\t        console.warn(key + ' used as a key, but it is not a string.');\n\t        key = String(key);\n\t    }\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            // The localStorage API doesn't return undefined values in an\n\t            // \"expected\" way, so undefined is always cast to null in all\n\t            // drivers. See: https://github.com/mozilla/localForage/pull/42\n\t            if (value === undefined) {\n\t                value = null;\n\t            }\n\t\n\t            // Save the original value to pass to the callback.\n\t            var originalValue = value;\n\t\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.serializer.serialize(value, function (value, error) {\n\t                if (error) {\n\t                    reject(error);\n\t                } else {\n\t                    dbInfo.db.transaction(function (t) {\n\t                        t.executeSql('INSERT OR REPLACE INTO ' + dbInfo.storeName + ' (key, value) VALUES (?, ?)', [key, value], function () {\n\t                            resolve(originalValue);\n\t                        }, function (t, error) {\n\t                            reject(error);\n\t                        });\n\t                    }, function (sqlError) {\n\t                        // The transaction failed; check\n\t                        // to see if it's a quota error.\n\t                        if (sqlError.code === sqlError.QUOTA_ERR) {\n\t                            // We reject the callback outright for now, but\n\t                            // it's worth trying to re-run the transaction.\n\t                            // Even if the user accepts the prompt to use\n\t                            // more storage on Safari, this error will\n\t                            // be called.\n\t                            //\n\t                            // TODO: Try to re-run the transaction.\n\t                            reject(sqlError);\n\t                        }\n\t                    });\n\t                }\n\t            });\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction removeItem(key, callback) {\n\t    var self = this;\n\t\n\t    // Cast the key to a string, as that's all we can set as a key.\n\t    if (typeof key !== 'string') {\n\t        console.warn(key + ' used as a key, but it is not a string.');\n\t        key = String(key);\n\t    }\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.db.transaction(function (t) {\n\t                t.executeSql('DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n\t                    resolve();\n\t                }, function (t, error) {\n\t\n\t                    reject(error);\n\t                });\n\t            });\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Deletes every item in the table.\n\t// TODO: Find out if this resets the AUTO_INCREMENT number.\n\tfunction clear(callback) {\n\t    var self = this;\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.db.transaction(function (t) {\n\t                t.executeSql('DELETE FROM ' + dbInfo.storeName, [], function () {\n\t                    resolve();\n\t                }, function (t, error) {\n\t                    reject(error);\n\t                });\n\t            });\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Does a simple `COUNT(key)` to get the number of items stored in\n\t// localForage.\n\tfunction length(callback) {\n\t    var self = this;\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.db.transaction(function (t) {\n\t                // Ahhh, SQL makes this one soooooo easy.\n\t                t.executeSql('SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n\t                    var result = results.rows.item(0).c;\n\t\n\t                    resolve(result);\n\t                }, function (t, error) {\n\t\n\t                    reject(error);\n\t                });\n\t            });\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\t// Return the key located at key index X; essentially gets the key from a\n\t// `WHERE id = ?`. This is the most efficient way I can think to implement\n\t// this rarely-used (in my experience) part of the API, but it can seem\n\t// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n\t// the ID of each key will change every time it's updated. Perhaps a stored\n\t// procedure for the `setItem()` SQL would solve this problem?\n\t// TODO: Don't change ID on `setItem()`.\n\tfunction key(n, callback) {\n\t    var self = this;\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.db.transaction(function (t) {\n\t                t.executeSql('SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n\t                    var result = results.rows.length ? results.rows.item(0).key : null;\n\t                    resolve(result);\n\t                }, function (t, error) {\n\t                    reject(error);\n\t                });\n\t            });\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\tfunction keys(callback) {\n\t    var self = this;\n\t\n\t    var promise = new _promise2.default(function (resolve, reject) {\n\t        self.ready().then(function () {\n\t            var dbInfo = self._dbInfo;\n\t            dbInfo.db.transaction(function (t) {\n\t                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n\t                    var keys = [];\n\t\n\t                    for (var i = 0; i < results.rows.length; i++) {\n\t                        keys.push(results.rows.item(i).key);\n\t                    }\n\t\n\t                    resolve(keys);\n\t                }, function (t, error) {\n\t\n\t                    reject(error);\n\t                });\n\t            });\n\t        }).catch(reject);\n\t    });\n\t\n\t    (0, _executeCallback2.default)(promise, callback);\n\t    return promise;\n\t}\n\t\n\tvar webSQLStorage = {\n\t    _driver: 'webSQLStorage',\n\t    _initStorage: _initStorage,\n\t    iterate: iterate,\n\t    getItem: getItem,\n\t    setItem: setItem,\n\t    removeItem: removeItem,\n\t    clear: clear,\n\t    length: length,\n\t    key: key,\n\t    keys: keys\n\t};\n\t\n\texports.default = webSQLStorage;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\tfunction executeTwoCallbacks(promise, callback, errorCallback) {\n\t    if (typeof callback === 'function') {\n\t        promise.then(callback);\n\t    }\n\t\n\t    if (typeof errorCallback === 'function') {\n\t        promise.catch(errorCallback);\n\t    }\n\t}\n\t\n\texports.default = executeTwoCallbacks;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\t\n\tvar _idb = __webpack_require__(5);\n\t\n\tvar _idb2 = _interopRequireDefault(_idb);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction isIndexedDBValid() {\n\t    try {\n\t        // Initialize IndexedDB; fall back to vendor-prefixed versions\n\t        // if needed.\n\t        if (!_idb2.default) {\n\t            return false;\n\t        }\n\t        // We mimic PouchDB here; just UA test for Safari (which, as of\n\t        // iOS 8/Yosemite, doesn't properly support IndexedDB).\n\t        // IndexedDB support is broken and different from Blink's.\n\t        // This is faster than the test case (and it's sync), so we just\n\t        // do this. *SIGH*\n\t        // http://bl.ocks.org/nolanlawson/raw/c83e9039edf2278047e9/\n\t        //\n\t        // We test for openDatabase because IE Mobile identifies itself\n\t        // as Safari. Oh the lulz...\n\t        if (typeof openDatabase !== 'undefined' && typeof navigator !== 'undefined' && navigator.userAgent && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)) {\n\t            return false;\n\t        }\n\t\n\t        return _idb2.default && typeof _idb2.default.open === 'function' &&\n\t        // Some Samsung/HTC Android 4.0-4.3 devices\n\t        // have older IndexedDB specs; if this isn't available\n\t        // their IndexedDB is too old for us to use.\n\t        // (Replaces the onupgradeneeded test.)\n\t        typeof IDBKeyRange !== 'undefined';\n\t    } catch (e) {\n\t        return false;\n\t    }\n\t}\n\t\n\texports.default = isIndexedDBValid;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\tfunction isLocalStorageValid() {\n\t    try {\n\t        return typeof localStorage !== 'undefined' && 'setItem' in localStorage && localStorage.setItem;\n\t    } catch (e) {\n\t        return false;\n\t    }\n\t}\n\t\n\texports.default = isLocalStorageValid;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\tfunction isWebSQLValid() {\n\t    return typeof openDatabase === 'function';\n\t}\n\t\n\texports.default = isWebSQLValid;\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {'use strict';\n\tvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\t\n\tvar scheduleDrain;\n\t\n\tif (process.browser) {\n\t  if (Mutation) {\n\t    var called = 0;\n\t    var observer = new Mutation(nextTick);\n\t    var element = global.document.createTextNode('');\n\t    observer.observe(element, {\n\t      characterData: true\n\t    });\n\t    scheduleDrain = function () {\n\t      element.data = (called = ++called % 2);\n\t    };\n\t  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n\t    var channel = new global.MessageChannel();\n\t    channel.port1.onmessage = nextTick;\n\t    scheduleDrain = function () {\n\t      channel.port2.postMessage(0);\n\t    };\n\t  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n\t    scheduleDrain = function () {\n\t\n\t      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t      var scriptEl = global.document.createElement('script');\n\t      scriptEl.onreadystatechange = function () {\n\t        nextTick();\n\t\n\t        scriptEl.onreadystatechange = null;\n\t        scriptEl.parentNode.removeChild(scriptEl);\n\t        scriptEl = null;\n\t      };\n\t      global.document.documentElement.appendChild(scriptEl);\n\t    };\n\t  } else {\n\t    scheduleDrain = function () {\n\t      setTimeout(nextTick, 0);\n\t    };\n\t  }\n\t} else {\n\t  scheduleDrain = function () {\n\t    process.nextTick(nextTick);\n\t  };\n\t}\n\t\n\tvar draining;\n\tvar queue = [];\n\t//named nextTick for less confusing stack traces\n\tfunction nextTick() {\n\t  draining = true;\n\t  var i, oldQueue;\n\t  var len = queue.length;\n\t  while (len) {\n\t    oldQueue = queue;\n\t    queue = [];\n\t    i = -1;\n\t    while (++i < len) {\n\t      oldQueue[i]();\n\t    }\n\t    len = queue.length;\n\t  }\n\t  draining = false;\n\t}\n\t\n\tmodule.exports = immediate;\n\tfunction immediate(task) {\n\t  if (queue.push(task) === 1 && !draining) {\n\t    scheduleDrain();\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(6)))\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\tvar immediate = __webpack_require__(14);\n\t\n\t/* istanbul ignore next */\n\tfunction INTERNAL() {}\n\t\n\tvar handlers = {};\n\t\n\tvar REJECTED = ['REJECTED'];\n\tvar FULFILLED = ['FULFILLED'];\n\tvar PENDING = ['PENDING'];\n\t/* istanbul ignore else */\n\tif (!process.browser) {\n\t  // in which we actually take advantage of JS scoping\n\t  var UNHANDLED = ['UNHANDLED'];\n\t}\n\t\n\tmodule.exports = exports = Promise;\n\t\n\tfunction Promise(resolver) {\n\t  if (typeof resolver !== 'function') {\n\t    throw new TypeError('resolver must be a function');\n\t  }\n\t  this.state = PENDING;\n\t  this.queue = [];\n\t  this.outcome = void 0;\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    this.handled = UNHANDLED;\n\t  }\n\t  if (resolver !== INTERNAL) {\n\t    safelyResolveThenable(this, resolver);\n\t  }\n\t}\n\t\n\tPromise.prototype.catch = function (onRejected) {\n\t  return this.then(null, onRejected);\n\t};\n\tPromise.prototype.then = function (onFulfilled, onRejected) {\n\t  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n\t    typeof onRejected !== 'function' && this.state === REJECTED) {\n\t    return this;\n\t  }\n\t  var promise = new this.constructor(INTERNAL);\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    if (this.handled === UNHANDLED) {\n\t      this.handled = null;\n\t    }\n\t  }\n\t  if (this.state !== PENDING) {\n\t    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n\t    unwrap(promise, resolver, this.outcome);\n\t  } else {\n\t    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n\t  }\n\t\n\t  return promise;\n\t};\n\tfunction QueueItem(promise, onFulfilled, onRejected) {\n\t  this.promise = promise;\n\t  if (typeof onFulfilled === 'function') {\n\t    this.onFulfilled = onFulfilled;\n\t    this.callFulfilled = this.otherCallFulfilled;\n\t  }\n\t  if (typeof onRejected === 'function') {\n\t    this.onRejected = onRejected;\n\t    this.callRejected = this.otherCallRejected;\n\t  }\n\t}\n\tQueueItem.prototype.callFulfilled = function (value) {\n\t  handlers.resolve(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallFulfilled = function (value) {\n\t  unwrap(this.promise, this.onFulfilled, value);\n\t};\n\tQueueItem.prototype.callRejected = function (value) {\n\t  handlers.reject(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallRejected = function (value) {\n\t  unwrap(this.promise, this.onRejected, value);\n\t};\n\t\n\tfunction unwrap(promise, func, value) {\n\t  immediate(function () {\n\t    var returnValue;\n\t    try {\n\t      returnValue = func(value);\n\t    } catch (e) {\n\t      return handlers.reject(promise, e);\n\t    }\n\t    if (returnValue === promise) {\n\t      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n\t    } else {\n\t      handlers.resolve(promise, returnValue);\n\t    }\n\t  });\n\t}\n\t\n\thandlers.resolve = function (self, value) {\n\t  var result = tryCatch(getThen, value);\n\t  if (result.status === 'error') {\n\t    return handlers.reject(self, result.value);\n\t  }\n\t  var thenable = result.value;\n\t\n\t  if (thenable) {\n\t    safelyResolveThenable(self, thenable);\n\t  } else {\n\t    self.state = FULFILLED;\n\t    self.outcome = value;\n\t    var i = -1;\n\t    var len = self.queue.length;\n\t    while (++i < len) {\n\t      self.queue[i].callFulfilled(value);\n\t    }\n\t  }\n\t  return self;\n\t};\n\thandlers.reject = function (self, error) {\n\t  self.state = REJECTED;\n\t  self.outcome = error;\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    if (self.handled === UNHANDLED) {\n\t      immediate(function () {\n\t        if (self.handled === UNHANDLED) {\n\t          process.emit('unhandledRejection', error, self);\n\t        }\n\t      });\n\t    }\n\t  }\n\t  var i = -1;\n\t  var len = self.queue.length;\n\t  while (++i < len) {\n\t    self.queue[i].callRejected(error);\n\t  }\n\t  return self;\n\t};\n\t\n\tfunction getThen(obj) {\n\t  // Make sure we only access the accessor once as required by the spec\n\t  var then = obj && obj.then;\n\t  if (obj && typeof obj === 'object' && typeof then === 'function') {\n\t    return function appyThen() {\n\t      then.apply(obj, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction safelyResolveThenable(self, thenable) {\n\t  // Either fulfill, reject or reject with error\n\t  var called = false;\n\t  function onError(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.reject(self, value);\n\t  }\n\t\n\t  function onSuccess(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.resolve(self, value);\n\t  }\n\t\n\t  function tryToUnwrap() {\n\t    thenable(onSuccess, onError);\n\t  }\n\t\n\t  var result = tryCatch(tryToUnwrap);\n\t  if (result.status === 'error') {\n\t    onError(result.value);\n\t  }\n\t}\n\t\n\tfunction tryCatch(func, value) {\n\t  var out = {};\n\t  try {\n\t    out.value = func(value);\n\t    out.status = 'success';\n\t  } catch (e) {\n\t    out.status = 'error';\n\t    out.value = e;\n\t  }\n\t  return out;\n\t}\n\t\n\texports.resolve = resolve;\n\tfunction resolve(value) {\n\t  if (value instanceof this) {\n\t    return value;\n\t  }\n\t  return handlers.resolve(new this(INTERNAL), value);\n\t}\n\t\n\texports.reject = reject;\n\tfunction reject(reason) {\n\t  var promise = new this(INTERNAL);\n\t  return handlers.reject(promise, reason);\n\t}\n\t\n\texports.all = all;\n\tfunction all(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var values = new Array(len);\n\t  var resolved = 0;\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    allResolver(iterable[i], i);\n\t  }\n\t  return promise;\n\t  function allResolver(value, i) {\n\t    self.resolve(value).then(resolveFromAll, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t    function resolveFromAll(outValue) {\n\t      values[i] = outValue;\n\t      if (++resolved === len && !called) {\n\t        called = true;\n\t        handlers.resolve(promise, values);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\texports.race = race;\n\tfunction race(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    resolver(iterable[i]);\n\t  }\n\t  return promise;\n\t  function resolver(value) {\n\t    self.resolve(value).then(function (response) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.resolve(promise, response);\n\t      }\n\t    }, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\tif (typeof global.Promise !== 'function') {\n\t  global.Promise = __webpack_require__(15);\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** localforage.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap db73142676192a40bbf6\n **/","import isIndexedDBValid from './utils/isIndexedDBValid';\nimport isWebSQLValid from './utils/isWebSQLValid';\nimport isLocalStorageValid from './utils/isLocalStorageValid';\nimport idbDriver from './drivers/indexeddb';\nimport websqlDriver from './drivers/websql';\nimport localstorageDriver from './drivers/localstorage';\nimport serializer from './utils/serializer';\nimport Promise from './utils/promise';\nimport executeTwoCallbacks from './utils/executeTwoCallbacks';\n\n// Custom drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar CustomDrivers = {};\n\nvar DriverType = {\n    INDEXEDDB: 'asyncStorage',\n    LOCALSTORAGE: 'localStorageWrapper',\n    WEBSQL: 'webSQLStorage'\n};\n\nvar DefaultDriverOrder = [\n    DriverType.INDEXEDDB,\n    DriverType.WEBSQL,\n    DriverType.LOCALSTORAGE\n];\n\nvar LibraryMethods = [\n    'clear',\n    'getItem',\n    'iterate',\n    'key',\n    'keys',\n    'length',\n    'removeItem',\n    'setItem'\n];\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nvar driverSupport = {};\n// Check to see if IndexedDB is available and if it is the latest\n// implementation; it's our preferred backend library. We use \"_spec_test\"\n// as the name of the database because it's not the one we'll operate on,\n// but it's useful to make sure its using the right spec.\n// See: https://github.com/mozilla/localForage/issues/128\ndriverSupport[DriverType.INDEXEDDB] = isIndexedDBValid();\n\ndriverSupport[DriverType.WEBSQL] = isWebSQLValid();\n\ndriverSupport[DriverType.LOCALSTORAGE] = isLocalStorageValid();\n\nvar isArray = Array.isArray || function(arg) {\n        return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function() {\n        var _args = arguments;\n        return localForageInstance.ready().then(function() {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var key in arg) {\n                if (arg.hasOwnProperty(key)) {\n                    if (isArray(arg[key])) {\n                        arguments[0][key] = arg[key].slice();\n                    } else {\n                        arguments[0][key] = arg[key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nfunction isLibraryDriver(driverName) {\n    for (var driver in DriverType) {\n        if (DriverType.hasOwnProperty(driver) &&\n            DriverType[driver] === driverName) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nclass LocalForage {\n    constructor(options) {\n        this.INDEXEDDB = DriverType.INDEXEDDB;\n        this.LOCALSTORAGE = DriverType.LOCALSTORAGE;\n        this.WEBSQL = DriverType.WEBSQL;\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver);\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n    config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if (typeof(options) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" +\n                    'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof(options) === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    }\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n    defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise(function(resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error(\n                    'Custom driver not compliant; see ' +\n                    'https://mozilla.github.io/localForage/#definedriver'\n                );\n                var namingError = new Error(\n                    'Custom driver name already in use: ' + driverObject._driver\n                );\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n                if (isLibraryDriver(driverObject._driver)) {\n                    reject(namingError);\n                    return;\n                }\n\n                var customDriverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0; i < customDriverMethods.length; i++) {\n                    var customDriverMethod = customDriverMethods[i];\n                    if (!customDriverMethod || !driverObject[customDriverMethod] ||\n                        typeof driverObject[customDriverMethod] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var supportPromise = Promise.resolve(true);\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        supportPromise = driverObject._support();\n                    } else {\n                        supportPromise = Promise.resolve(!!driverObject._support);\n                    }\n                }\n\n                supportPromise.then(function(supportResult) {\n                    driverSupport[driverName] = supportResult;\n                    CustomDrivers[driverName] = driverObject;\n                    resolve();\n                }, reject);\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    }\n\n    driver() {\n        return this._driver || null;\n    }\n\n    getDriver(driverName, callback, errorCallback) {\n        var self = this;\n        var getDriverPromise = Promise.resolve().then(() => {\n            if (isLibraryDriver(driverName)) {\n                switch (driverName) {\n                    case self.INDEXEDDB:\n                        return idbDriver;\n                    case self.LOCALSTORAGE:\n                        return localstorageDriver;\n                    case self.WEBSQL:\n                        return websqlDriver;\n                }\n            } else if (CustomDrivers[driverName]) {\n                return CustomDrivers[driverName];\n            } else {\n                throw new Error('Driver not found.');\n            }\n        });\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    }\n\n    getSerializer(callback) {\n        var serializerPromise = Promise.resolve(serializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    }\n\n    ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(() => {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    }\n\n    setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function initDriver(supportedDrivers) {\n            return function() {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName)\n                            .then(driver => {\n                                self._extend(driver);\n                                setDriverToConfig();\n\n                                self._ready = self._initStorage(self._config);\n                                return self._ready;\n                            })\n                            .catch(driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ?\n            this._driverSet.catch(() => Promise.resolve()) :\n            Promise.resolve();\n\n        this._driverSet = oldDriverSetDone.then(() => {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName)\n                .then(driver => {\n                    self._driver = driver._driver;\n                    setDriverToConfig();\n                    self._wrapLibraryMethodsWithReady();\n                    self._initDriver = initDriver(supportedDrivers);\n                });\n        }).catch(() => {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    }\n\n    supports(driverName) {\n        return !!driverSupport[driverName];\n    }\n\n    _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    }\n\n    _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    }\n\n    _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0; i < LibraryMethods.length; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    }\n\n    createInstance(options) {\n        return new LocalForage(options);\n    }\n}\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\nexport default new LocalForage();\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/localforage.js\n **/","// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nrequire('lie/polyfill');\nexport default Promise;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/promise.js\n **/","function executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function(result) {\n            callback(null, result);\n        }, function(error) {\n            callback(error);\n        });\n    }\n}\n\nexport default executeCallback;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/executeCallback.js\n **/","import createBlob from './createBlob';\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH +\n    TYPE_ARRAYBUFFER.length;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64String += BASE_CHARS[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if ((bytes.length % 3) === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueString = '';\n    if (value) {\n        valueString = value.toString();\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (value.toString() === '[object ArrayBuffer]' ||\n        value.buffer &&\n        value.buffer.toString() === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueString === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueString === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueString === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueString === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueString === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueString === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueString === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueString === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueString === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueString === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function() {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' +\n                bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \",\n                value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0,\n            SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH,\n        TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], {type: blobType});\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unknown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\nexport default localforageSerializer;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/serializer.js\n **/","// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n            typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n            typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n            WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\nexport default createBlob;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/createBlob.js\n **/","function getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    if (typeof indexedDB !== 'undefined') {\n        return indexedDB;\n    }\n    if (typeof webkitIndexedDB !== 'undefined') {\n        return webkitIndexedDB;\n    }\n    if (typeof mozIndexedDB !== 'undefined') {\n        return mozIndexedDB;\n    }\n    if (typeof OIndexedDB !== 'undefined') {\n        return OIndexedDB;\n    }\n    if (typeof msIndexedDB !== 'undefined') {\n        return msIndexedDB;\n    }\n}\n\nvar idb = getIDB();\nexport default idb;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/idb.js\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 6\n ** module chunks = 0\n **/","import createBlob from '../utils/createBlob';\nimport idb from '../utils/idb';\nimport Promise from '../utils/promise';\nimport executeCallback from '../utils/executeCallback';\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs;\nvar dbContexts;\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n// Fetch a blob using ajax. This reveals bugs in Chrome < 43.\n// For details on all this junk:\n// https://github.com/nolanlawson/state-of-binary-data-in-the-browser#readme\nfunction _blobAjax(url) {\n    return new Promise(function(resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url);\n        xhr.withCredentials = true;\n        xhr.responseType = 'arraybuffer';\n\n        xhr.onreadystatechange = function() {\n            if (xhr.readyState !== 4) {\n                return;\n            }\n            if (xhr.status === 200) {\n                return resolve({\n                    response: xhr.response,\n                    type: xhr.getResponseHeader('Content-Type')\n                });\n            }\n            reject({status: xhr.status, response: xhr.response});\n        };\n        xhr.send();\n    });\n}\n\n//\n// Detect blob support. Chrome didn't support it until version 38.\n// In version 37 they had a broken version where PNGs (and possibly\n// other binary types) aren't stored correctly, because when you fetch\n// them, the content type is always null.\n//\n// Furthermore, they have some outstanding bugs where blobs occasionally\n// are read by FileReader as null, or by ajax as 404s.\n//\n// Sadly we use the 404 bug to detect the FileReader bug, so if they\n// get fixed independently and released in different versions of Chrome,\n// then the bug could come back. So it's worthwhile to watch these issues:\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise(function(resolve, reject) {\n        var blob = createBlob([''], {type: 'image/png'});\n        var txn = idb.transaction([DETECT_BLOB_SUPPORT_STORE], 'readwrite');\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n        txn.oncomplete = function() {\n            // have to do it in a separate transaction, else the correct\n            // content type is always returned\n            var blobTxn = idb.transaction([DETECT_BLOB_SUPPORT_STORE],\n                'readwrite');\n            var getBlobReq = blobTxn.objectStore(\n                DETECT_BLOB_SUPPORT_STORE).get('key');\n            getBlobReq.onerror = reject;\n            getBlobReq.onsuccess = function(e) {\n\n                var storedBlob = e.target.result;\n                var url = URL.createObjectURL(storedBlob);\n\n                _blobAjax(url).then(function(res) {\n                    resolve(!!(res && res.type === 'image/png'));\n                }, function() {\n                    resolve(false);\n                }).then(function() {\n                    URL.revokeObjectURL(url);\n                });\n            };\n        };\n        txn.onerror = txn.onabort = reject;\n    }).catch(function() {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function(value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise(function(resolve) {\n        deferredOperation.resolve = resolve;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function() {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise(function(resolve, reject) {\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function(e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' +\n                            ' has been upgraded from version ' + e.oldVersion +\n                            ' to version ' + e.newVersion +\n                            ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function() {\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function() {\n            resolve(openreq.result);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' +\n                ' can\\'t be downgraded from version ' + dbInfo.db.version +\n                ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise(function(resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function(e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], {type: encodedBlob.type});\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function() {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    promise.then(callback, callback);\n    return promise;\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Initialize a singleton container for all running localForages.\n    if (!dbContexts) {\n        dbContexts = {};\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = {\n            // Running localForages sharing a database.\n            forages: [],\n            // Shared database.\n            db: null,\n            // Database readiness (promise).\n            dbReady: null,\n            // Deferred operations on the database.\n            deferredOperations: []\n        };\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) { // Don't wait for itself...\n            initPromises.push(forage._initReady().catch(ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise.all(initPromises).then(function() {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function(db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function(db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) { // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key +\n            ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')\n                .objectStore(dbInfo.storeName);\n            var req = store.get(key);\n\n            req.onsuccess = function() {\n                var value = req.result;\n                if (value === undefined) {\n                    value = null;\n                }\n                if (_isEncodedBlob(value)) {\n                    value = _decodeBlob(value);\n                }\n                resolve(value);\n            };\n\n            req.onerror = function() {\n                reject(req.error);\n            };\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')\n                .objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var iterationNumber = 1;\n\n            req.onsuccess = function() {\n                var cursor = req.result;\n\n                if (cursor) {\n                    var value = cursor.value;\n                    if (_isEncodedBlob(value)) {\n                        value = _decodeBlob(value);\n                    }\n                    var result = iterator(value, cursor.key,\n                        iterationNumber++);\n\n                    if (result !== void(0)) {\n                        resolve(result);\n                    } else {\n                        cursor.continue();\n                    }\n                } else {\n                    resolve();\n                }\n            };\n\n            req.onerror = function() {\n                reject(req.error);\n            };\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key +\n            ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise(function(resolve, reject) {\n        var dbInfo;\n        self.ready().then(function() {\n            dbInfo = self._dbInfo;\n            if (value instanceof Blob) {\n                return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function(value) {\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n\n            // The reason we don't _save_ null is because IE 10 does\n            // not support saving the `null` type in IndexedDB. How\n            // ironic, given the bug below!\n            // See: https://github.com/mozilla/localForage/issues/161\n            if (value === null) {\n                value = undefined;\n            }\n\n            transaction.oncomplete = function() {\n                // Cast to undefined so the value passed to\n                // callback/promise is the same as what one would get out\n                // of `getItem()` later. This leads to some weirdness\n                // (setItem('foo', undefined) will return `null`), but\n                // it's not my fault localStorage is our baseline and that\n                // it's weird.\n                if (value === undefined) {\n                    value = null;\n                }\n\n                resolve(value);\n            };\n            transaction.onabort = transaction.onerror = function() {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n\n            var req = store.put(value, key);\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key +\n            ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n\n            // We use a Grunt task to make this safe for IE and some\n            // versions of Android (including those used by Cordova).\n            // Normally IE won't like `.delete()` and will insist on\n            // using `['delete']()`, but we have a build step that\n            // fixes this for us now.\n            var req = store.delete(key);\n            transaction.oncomplete = function() {\n                resolve();\n            };\n\n            transaction.onerror = function() {\n                reject(req.error);\n            };\n\n            // The request will be also be aborted if we've exceeded our storage\n            // space.\n            transaction.onabort = function() {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n            var transaction = dbInfo.db.transaction(dbInfo.storeName, 'readwrite');\n            var store = transaction.objectStore(dbInfo.storeName);\n            var req = store.clear();\n\n            transaction.oncomplete = function() {\n                resolve();\n            };\n\n            transaction.onabort = transaction.onerror = function() {\n                var err = req.error ? req.error : req.transaction.error;\n                reject(err);\n            };\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')\n                .objectStore(dbInfo.storeName);\n            var req = store.count();\n\n            req.onsuccess = function() {\n                resolve(req.result);\n            };\n\n            req.onerror = function() {\n                reject(req.error);\n            };\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')\n                .objectStore(dbInfo.storeName);\n\n            var advanced = false;\n            var req = store.openCursor();\n            req.onsuccess = function() {\n                var cursor = req.result;\n                if (!cursor) {\n                    // this means there weren't enough keys\n                    resolve(null);\n\n                    return;\n                }\n\n                if (n === 0) {\n                    // We have the first key, return it if that's what they\n                    // wanted.\n                    resolve(cursor.key);\n                } else {\n                    if (!advanced) {\n                        // Otherwise, ask the cursor to skip ahead n\n                        // records.\n                        advanced = true;\n                        cursor.advance(n);\n                    } else {\n                        // When we get here, we've got the nth key.\n                        resolve(cursor.key);\n                    }\n                }\n            };\n\n            req.onerror = function() {\n                reject(req.error);\n            };\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n            var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')\n                .objectStore(dbInfo.storeName);\n\n            var req = store.openCursor();\n            var keys = [];\n\n            req.onsuccess = function() {\n                var cursor = req.result;\n\n                if (!cursor) {\n                    resolve(keys);\n                    return;\n                }\n\n                keys.push(cursor.key);\n                cursor.continue();\n            };\n\n            req.onerror = function() {\n                reject(req.error);\n            };\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys\n};\nexport default asyncStorage;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/drivers/indexeddb.js\n **/","// If IndexedDB isn't available, we'll fall back to localStorage.\n// Note that this will have considerable performance and storage\n// side-effects (all data will be serialized on save and only data that\n// can be converted to a string via `JSON.stringify()` will be saved).\n\nimport serializer from '../utils/serializer';\nimport Promise from '../utils/promise';\nimport executeCallback from '../utils/executeCallback';\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = dbInfo.name + '/';\n\n    if (dbInfo.storeName !== self._defaultConfig.storeName) {\n        dbInfo.keyPrefix += dbInfo.storeName + '/';\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = serializer;\n\n    return Promise.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear(callback) {\n    var self = this;\n    var promise = self.ready().then(function() {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key +\n            ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function() {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function() {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength),\n                iterationNumber++);\n\n            if (value !== void(0)) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function() {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n    var promise = self.ready().then(function() {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length(callback) {\n    var self = this;\n    var promise = self.keys().then(function(keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key +\n            ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function() {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key +\n            ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = self.ready().then(function() {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise(function(resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function(value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' ||\n                            e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage,\n    // Default API, from Gaia/localStorage.\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys\n};\n\nexport default localStorageWrapper;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/drivers/localstorage.js\n **/","import serializer from '../utils/serializer';\nimport Promise from '../utils/promise';\nimport executeCallback from '../utils/executeCallback';\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof(options[i]) !== 'string' ?\n                        options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise(function(resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version),\n                                     dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function(t) {\n            t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName +\n                         ' (id INTEGER PRIMARY KEY, key unique, value)', [],\n                         function() {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function(t, error) {\n                reject(error);\n            });\n        });\n    });\n\n    dbInfo.serializer = serializer;\n    return dbInfoPromise;\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key +\n                            ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function(t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName +\n                             ' WHERE key = ? LIMIT 1', [key],\n                             function(t, results) {\n                    var result = results.rows.length ?\n                                 results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function(t, error) {\n\n                    reject(error);\n                });\n            });\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function(t) {\n                t.executeSql('SELECT * FROM ' + dbInfo.storeName, [],\n                    function(t, results) {\n                        var rows = results.rows;\n                        var length = rows.length;\n\n                        for (var i = 0; i < length; i++) {\n                            var item = rows.item(i);\n                            var result = item.value;\n\n                            // Check to see if this is serialized content\n                            // we need to unpack.\n                            if (result) {\n                                result = dbInfo.serializer.deserialize(result);\n                            }\n\n                            result = iterator(result, item.key, i + 1);\n\n                            // void(0) prevents problems with redefinition\n                            // of `undefined`.\n                            if (result !== void(0)) {\n                                resolve(result);\n                                return;\n                            }\n                        }\n\n                        resolve();\n                    }, function(t, error) {\n                        reject(error);\n                    });\n            });\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key +\n                            ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function(value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function(t) {\n                        t.executeSql('INSERT OR REPLACE INTO ' +\n                                     dbInfo.storeName +\n                                     ' (key, value) VALUES (?, ?)',\n                                     [key, value], function() {\n                            resolve(originalValue);\n                        }, function(t, error) {\n                            reject(error);\n                        });\n                    }, function(sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // TODO: Try to re-run the transaction.\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key +\n                            ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function(t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName +\n                             ' WHERE key = ?', [key],\n                             function() {\n                    resolve();\n                }, function(t, error) {\n\n                    reject(error);\n                });\n            });\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function(t) {\n                t.executeSql('DELETE FROM ' + dbInfo.storeName, [],\n                             function() {\n                    resolve();\n                }, function(t, error) {\n                    reject(error);\n                });\n            });\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function(t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                t.executeSql('SELECT COUNT(key) as c FROM ' +\n                             dbInfo.storeName, [], function(t, results) {\n                    var result = results.rows.item(0).c;\n\n                    resolve(result);\n                }, function(t, error) {\n\n                    reject(error);\n                });\n            });\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function(t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName +\n                             ' WHERE id = ? LIMIT 1', [n + 1],\n                             function(t, results) {\n                    var result = results.rows.length ?\n                                 results.rows.item(0).key : null;\n                    resolve(result);\n                }, function(t, error) {\n                    reject(error);\n                });\n            });\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise(function(resolve, reject) {\n        self.ready().then(function() {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function(t) {\n                t.executeSql('SELECT key FROM ' + dbInfo.storeName, [],\n                             function(t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function(t, error) {\n\n                    reject(error);\n                });\n            });\n        }).catch(reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage,\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys\n};\n\nexport default webSQLStorage;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/drivers/websql.js\n **/","function executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise.catch(errorCallback);\n    }\n}\n\nexport default executeTwoCallbacks;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/executeTwoCallbacks.js\n **/","import idb from './idb';\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb) {\n            return false;\n        }\n        // We mimic PouchDB here; just UA test for Safari (which, as of\n        // iOS 8/Yosemite, doesn't properly support IndexedDB).\n        // IndexedDB support is broken and different from Blink's.\n        // This is faster than the test case (and it's sync), so we just\n        // do this. *SIGH*\n        // http://bl.ocks.org/nolanlawson/raw/c83e9039edf2278047e9/\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        if (typeof openDatabase !== 'undefined' && typeof navigator !== 'undefined' &&\n            navigator.userAgent &&\n            /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)) {\n            return false;\n        }\n\n        return idb &&\n            typeof idb.open === 'function' &&\n                // Some Samsung/HTC Android 4.0-4.3 devices\n                // have older IndexedDB specs; if this isn't available\n                // their IndexedDB is too old for us to use.\n                // (Replaces the onupgradeneeded test.)\n            typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\nexport default isIndexedDBValid;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/isIndexedDBValid.js\n **/","function isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' &&\n            ('setItem' in localStorage) &&\n            localStorage.setItem;\n    } catch (e) {\n        return false;\n    }\n}\n\nexport default isLocalStorageValid;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/isLocalStorageValid.js\n **/","function isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\nexport default isWebSQLValid;\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/isWebSQLValid.js\n **/","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\nif (process.browser) {\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n} else {\n  scheduleDrain = function () {\n    process.nextTick(nextTick);\n  };\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/immediate/lib/index.js\n ** module id = 14\n ** module chunks = 0\n **/","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n/* istanbul ignore else */\nif (!process.browser) {\n  // in which we actually take advantage of JS scoping\n  var UNHANDLED = ['UNHANDLED'];\n}\n\nmodule.exports = exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    this.handled = UNHANDLED;\n  }\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype.catch = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (this.handled === UNHANDLED) {\n      this.handled = null;\n    }\n  }\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (self.handled === UNHANDLED) {\n      immediate(function () {\n        if (self.handled === UNHANDLED) {\n          process.emit('unhandledRejection', error, self);\n        }\n      });\n    }\n  }\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nexports.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nexports.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nexports.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nexports.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lie/lib/index.js\n ** module id = 15\n ** module chunks = 0\n **/","'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = require('./lib');\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lie/polyfill.js\n ** module id = 16\n ** module chunks = 0\n **/"],"sourceRoot":""}